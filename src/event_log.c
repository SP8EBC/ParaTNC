/*
 * event_log.c
 *
 *  Created on: May 26, 2024
 *      Author: mateusz
 */

#include "event_log.h"
#include "./nvm/nvm_event.h"
#include "main_master_time.h"
#include "variant.h"

#include <string.h>
#include <stdio.h>

#include "events_definitions/events_aprs_rf.h"
#include "events_definitions/events_aprsis.h"
#include "events_definitions/events_drv_i2c.h"
#include "events_definitions/events_drv_spi.h"
#include "events_definitions/events_drv_uart.h"
#include "events_definitions/events_drv_anemometer.h"
#include "events_definitions/events_umb.h"
#include "events_definitions/events_gsm_gprs.h"
#include "events_definitions/events_http_client.h"
#include "events_definitions/events_kiss.h"
#include "events_definitions/events_main.h"
#include "events_definitions/events_modbus.h"
#include "events_definitions/events_packet_tx_handler.h"
#include "events_definitions/events_pwr_save.h"
#include "events_definitions/events_tcpip.h"
#include "events_definitions/events_wx_handler.h"



/// ==================================================================================================
///	LOCAL DEFINITIONS
/// ==================================================================================================

#define EVENT_LOG_ASYNC_FIFO_LENGTH 16

/// ==================================================================================================
///	LOCAL VARIABLES
/// ==================================================================================================

static event_log_t event_log_async_fifo[EVENT_LOG_ASYNC_FIFO_LENGTH];

static int8_t event_log_fifo_current_depth = 0;

/// ==================================================================================================
///	GLOBAL VARIABLES
/// ==================================================================================================

/**
 * Strings for different event sources
 */
const char * event_log_str_src_main 				= "MAIN\0";
const char * event_log_str_src_wx_handler 			= "WX_HANDLER\0";
const char * event_log_str_src_pwr_save 			= "PWR_SAVE\0";
const char * event_log_str_src_packet_tx_handler 	= "PKT_TX_HNDL\0";
const char * event_log_str_src_aprsis 				= "APRSIS\0";
const char * event_log_str_src_kiss 				= "KISS\0";
const char * event_log_str_src_aprs_rf 				= "APRS_RF\0";
const char * event_log_str_src_gsm_gprs				= "GSM_GPRS\0";
const char * event_log_str_src_tcpip 				= "TCPIP\0";
const char * event_log_str_src_http_client 			= "HTTP\0";
const char * event_log_str_src_modbus 				= "RTU\0";
const char * event_log_str_src_umb 					= "UMB\0";
const char * event_log_str_src_drv_anemometer 		= "ANEMOMETER\0";
const char * event_log_str_src_drv_i2c 				= "I2C\0";
const char * event_log_str_src_drv_uart 			= "UART\0";
const char * event_log_str_src_drv_spi 				= "SPI\0";

/**
 * Strings for different severity
 *
 */
const char * event_log_str_severity_debug 			= "DEBUG\0";
const char * event_log_str_severity_info 			= "INFO\0";
const char * event_log_str_severity_info_cyclic 	= "INFO_CYCLIC\0";
const char * event_log_str_severity_warning 		= "WARNING\0";
const char * event_log_str_severity_error 			= "ERROR\0";
const char * event_log_str_severity_assert 			= "ASSERT\0";
const char * event_log_str_severity_bootup 			= "BOOTUP\0";
const char * event_log_str_severity_timesync 		= "TIMESYNC\0";

/**
 * Strings for events generated by "main" sources
 */
const char * event_log_str_main_bootup_complete		= "BOOTUP_COMPLETE\0";
const char * event_log_str_main_timesync_bootup		= "TS_BOOTUP\0";
const char * event_log_str_main_timesync_periodic	= "TS_PERIODIC\0";
const char * event_log_str_main_timesync_ntp		= "TS_NTP\0";
const char * event_log_str_main_info_cyclic			= "CYCLIC\0";

/**
 * Strings for events generated by "drv_anemometer" sources
 *
 */
const char * event_log_str_drv_anemometer_no_pulses_int_fired = "NO_PULSES_INT_FIRED\0";
const char * event_log_str_drv_anemometer_excesive_slew_rate = "EXCESIVE_SLEW\0";
const char * event_log_str_drv_anemometer_uf_conv_not_working = "UF_CONV_NOT_WRKNG\0";
const char * event_log_str_drv_anemometer_uf_freq_to_hi = "UF_FREQ_TOO_HI\0";
const char * event_log_str_drv_anemometer_qf_not_full = "QF_NOT_FULL\0";

/**
 * Strings for events generated by "gsm gprs"
 */
const char * event_log_str_tcpip_error_apn_config_missing = "NO_APN_CONFIG\0";
const char * event_log_str_tcpip_warn_async_msg_detected = "ASYNC_MSG_DETECT\0";


/**
 * Strings for events generated by "pwr_save"
 */
const char * event_log_str_pwr_save_going_sleep = "B+LOW_GOING_SLEEP\0";

/**
 * Strings for events generated by "tcpip"
 */
const char * event_log_str_tcpip_error_connecting = "ERR_CONNECTING\0";
const char * event_log_str_tcpip_error_connecting_no_modem_resp = "ERR_CONN_NO_RESP\0";


/**
 * Strings for events generated by "wx_handler" sources
 *
 * #define EVENTS_WX_HANDLER_WARN_TEMPERATURE_INT_FAILED		(0x01U)
#define EVENTS_WX_HANDLER_WARN_TEMPERATURE_DALLAS_DEGR		(0x02U)
#define EVENTS_WX_HANDLER_WARN_TEMPERATURE_DALLAS_NAV		(0x03U)
#define EVENTS_WX_HANDLER_WARN_TEMPERATURE_EXCESIVE_SLEW	(0x04U)

#define EVENTS_WX_HANDLER_WARN_PRESSURE_FAILED				(0x05U)
#define EVENTS_WX_HANDLER_WARN_HUMIDITY_FAILED				(0x06U)
 *
 *
 */
const char * event_log_str_wx_handler_temperature_int_failed = "TEMP_INT_FAIL\0";
const char * event_log_str_wx_handler_temperature_dallas_degraded = "DALLAS_DEGR\0";
const char * event_log_str_wx_handler_temperature_dallas_not_avble = "DALLAS_NVBLE\0";
const char * event_log_str_wx_handler_temperature_excesive_slew = "EXCSVE_SLEW\0";
const char * event_log_str_wx_handler_temperature_pressure_fail = "PRESSURE_FL\0";
const char * event_log_str_wx_handler_temperature_humidity_fail = "HUMID_FL\0";


/// ==================================================================================================
///	GLOBAL FUNCTIONS
/// ==================================================================================================

/**
 *
 */
void event_log_init (void)
{
	memset (event_log_async_fifo, 0x00, sizeof (event_log_t) * EVENT_LOG_ASYNC_FIFO_LENGTH);
	event_log_fifo_current_depth = 0;
}

/**
 * Stores new event asynchronously. Events are written into all volatile, RAM mapped areas
 * immediately, but FLASH based areas are synchronized periodically.
 * @param severity
 * @param source
 * @param wparam
 * @param lparam
 * @param lparam2
 */
int8_t event_log (event_log_severity_t severity,
				event_log_source_t source,
				uint8_t event_id,
				uint8_t param,
				uint8_t param2,
				uint16_t wparam,
				uint16_t wparam2,
				uint32_t lparam,
				uint32_t lparam2)
{
	return 0;
}

/**
 * Stores an event synchronously to all targer areas
 * @param severity
 * @param source
 * @param event_id
 * @param param
 * @param param2
 * @param wparam
 * @param wparam2
 * @param lparam
 * @param lparam2
 * @return
 */
int8_t event_log_sync (event_log_severity_t severity,
					 event_log_source_t source,
 					 uint8_t event_id,
					 uint8_t param,
					 uint8_t param2,
					 uint16_t wparam,
					 uint16_t wparam2,
					 uint32_t lparam,
					 uint32_t lparam2)
{
	event_log_t new_event = {0u};

	// left this to zero, to be automatically set to appropriate value by
	// pushing function
	new_event.event_counter_id = 0;

	new_event.event_id = event_id;
	new_event.event_master_time = main_get_master_time();
	new_event.severity_and_source = EVENT_LOG_SET_SEVERITY_SOURCE(severity, source);

	new_event.param = param;
	new_event.param2 = param2;
	new_event.wparam = wparam;
	new_event.wparam2 = wparam2;
	new_event.lparam = lparam;
	new_event.lparam2 = lparam2;

	const nvm_event_result_t res = nvm_event_log_push_new_event(&new_event);

	if (res == NVM_EVENT_OK) {
		return 0;
	}
	else {
		return -1;
	}
}

const char * event_log_severity_to_str(event_log_severity_t severity) {

	switch (severity) {
		case EVENT_DEBUG:		return event_log_str_severity_debug;	/**< EVENT_DEBUG */
		case EVENT_INFO:		return event_log_str_severity_info;		/**< EVENT_INFO */
		case EVENT_INFO_CYCLIC: return event_log_str_severity_info_cyclic;
		case EVENT_WARNING:		return event_log_str_severity_warning;	/**< EVENT_WARNING */
		case EVENT_ERROR:		return event_log_str_severity_error;	/**< EVENT_ERROR */
		case EVENT_ASSERT:		return event_log_str_severity_assert;	/**< EVENT_ASSERT assert failure, which result in hard reset*/
		case EVENT_BOOTUP:		return event_log_str_severity_bootup;	/**< EVENT_BOOTUP all info events generated during bootup */
		case EVENT_TIMESYNC: 	return event_log_str_severity_timesync;	/**< EVENT_TIMESYNC event generated once at startup and then every 6 hours to
								   keep master_time and RTC date and time sync */
	}

	return 0;
}

/**
 * Returns a pointer to a string representing event source
 * @param src
 * @return
 */
const char * event_log_source_to_str(event_log_source_t src) {
	switch (src) {
		case EVENT_SRC_MAIN:				return event_log_str_src_main; break;
		case EVENT_SRC_WX_HANDLER:			return event_log_str_src_wx_handler; break;
		case EVENT_SRC_PWR_SAVE:			return event_log_str_src_pwr_save; break;
		case EVENT_SRC_PACKET_TX_HANDLER:	return event_log_str_src_packet_tx_handler; break;
		case EVENT_SRC_APRSIS:				return event_log_str_src_aprsis; break;
		case EVENT_SRC_KISS:				return event_log_str_src_kiss; break;
		case EVENT_SRC_APRS_RF:				return event_log_str_src_aprs_rf; break;
		case EVENT_SRC_GSM_GPRS:			return event_log_str_src_gsm_gprs; break;
		case EVENT_SRC_TCPIP:				return event_log_str_src_tcpip; break;
		case EVENT_SRC_HTTP_CLIENT:			return event_log_str_src_http_client; break;
		case EVENT_SRC_MODBUS:				return event_log_str_src_modbus; break;
		case EVENT_SRC_UMB:					return event_log_str_src_umb; break;
		case EVENT_SRC_DRV_ANEMOMETER:		return event_log_str_src_drv_anemometer; break;
		case EVENT_SRC_DRV_I2C:				return event_log_str_src_drv_i2c; break;
		case EVENT_SRC_DRV_UART:			return event_log_str_src_drv_uart; break;
		case EVENT_SRC_DRV_SPI:				return event_log_str_src_drv_spi; break;
		default: return 0;
	}
}

/**
 *
 * @param source
 * @param event_id
 * @return
 */
const char * event_id_to_str(event_log_source_t source, uint8_t event_id)
{
	const char * out = 0x0;

	switch (source) {
		case EVENT_SRC_MAIN: {

			if (event_id == EVENTS_MAIN_BOOTUP_COMPLETE) {
				out = event_log_str_main_bootup_complete;
			}
			else if (event_id == EVENTS_MAIN_TIMESYNC_BOOTUP) {
				out = event_log_str_main_timesync_bootup;
			}
			else if (event_id == EVENTS_MAIN_TIMESYNC_PERIODIC) {
				out = event_log_str_main_timesync_periodic;
			}
			else if (event_id == EVENTS_MAIN_TIMESYNC_NTP) {
				out = event_log_str_main_timesync_ntp;
			}
			else if (event_id == EVENTS_MAIN_CYCLIC) {
				out = event_log_str_main_info_cyclic;
			}
			break;
		}
		case EVENT_SRC_WX_HANDLER:	{

			if (event_id == EVENTS_WX_HANDLER_WARN_TEMPERATURE_INT_FAILED) {
				out = event_log_str_wx_handler_temperature_int_failed;
			}
			else if (event_id == EVENTS_WX_HANDLER_WARN_TEMPERATURE_DALLAS_DEGR) {
				out = event_log_str_wx_handler_temperature_dallas_degraded;
			}
			else if (event_id == EVENTS_WX_HANDLER_WARN_TEMPERATURE_DALLAS_NAV) {
				out = event_log_str_wx_handler_temperature_dallas_not_avble;
			}
			else if (event_id == EVENTS_WX_HANDLER_WARN_TEMPERATURE_EXCESIVE_SLEW) {
				out = event_log_str_wx_handler_temperature_excesive_slew;
			}
			else if (event_id == EVENTS_WX_HANDLER_WARN_PRESSURE_FAILED) {
				out = event_log_str_wx_handler_temperature_pressure_fail;
			}
			else if (event_id == EVENTS_WX_HANDLER_WARN_HUMIDITY_FAILED) {
				out = event_log_str_wx_handler_temperature_humidity_fail;
			}

			break;
		}
		case EVENT_SRC_PWR_SAVE:			 break;
			if (event_id == EVENTS_PWR_SAVE_BATT_LOW_GOING_SLEEP) {
				out = event_log_str_pwr_save_going_sleep;
			}
			break;
		case EVENT_SRC_PACKET_TX_HANDLER:	 break;
		case EVENT_SRC_APRSIS:				 break;
		case EVENT_SRC_KISS:				 break;
		case EVENT_SRC_APRS_RF:				 break;
		case EVENT_SRC_GSM_GPRS:			 
			if (event_id == EVENTS_GSM_GPRS_ERR_APN_CONFIGURATION_MISSING) {
				out = event_log_str_tcpip_error_apn_config_missing;
			}
			else if (event_id == EVENTS_GSM_GPRS_WARN_ASYNC_MSG_DETECTED) {
				out = event_log_str_tcpip_warn_async_msg_detected;
			}

			break;
		case EVENT_SRC_TCPIP:				 
			if (event_id == EVENTS_TCPIP_ERR_CONNECTING) {
				out = event_log_str_tcpip_error_connecting;
			}
			else if (event_id == EVENTS_TCPIP_ERR_CONNECTING_NO_MODEM_RESPONSE) {
				out = event_log_str_tcpip_error_connecting_no_modem_resp;
			}

			break;
		case EVENT_SRC_HTTP_CLIENT:			 break;
		case EVENT_SRC_MODBUS:				 break;
		case EVENT_SRC_UMB:					 break;
		case EVENT_SRC_DRV_ANEMOMETER: {

			if (event_id == EVENTS_DRV_ANEMOMETER_WARN_NO_PULSES_INT_FIRED) {
				out = event_log_str_drv_anemometer_no_pulses_int_fired;
			}
			else if (event_id == EVENTS_DRV_ANEMOMETER_WARN_EXCESIVE_SLEW) {
				out = event_log_str_drv_anemometer_excesive_slew_rate;
			}
			else if (event_id == EVENTS_DRV_ANEMOMETER_ERROR_UF_CONV_NOT_WORKING) {
				out = event_log_str_drv_anemometer_uf_conv_not_working;
			}
			else if (event_id == EVENTS_DRV_ANEMOMETER_ERROR_UF_FREQ_TOO_HI) {
				out = event_log_str_drv_anemometer_uf_freq_to_hi;
			}
			else if (event_id == EVENTS_DRV_ANEMOMETER_WARN_QF_NOT_FULL) {
				out = event_log_str_drv_anemometer_qf_not_full;
			}

			break;
		}
		case EVENT_SRC_DRV_I2C:				 break;
		case EVENT_SRC_DRV_UART:			 break;
		case EVENT_SRC_DRV_SPI:				 break;
		default: out = 0x0;
	}

	return out;

}

/**
 * Generates string representation of given event log in exposed form
 * @param exposed pointer to an event to be converted
 * @param output char buffer to place a string into
 * @param output_ln maximum length of output string
 * @return length of assembled string
 */
uint16_t event_exposed_to_string(const event_log_exposed_t * exposed, char * output, uint16_t output_ln)
{
	uint16_t out = 0;

	char severity = ' ';

	switch (exposed->severity) {
		case EVENT_DEBUG:		severity = 'D'; break;
		case EVENT_INFO:		severity = 'I'; break;
		case EVENT_INFO_CYCLIC:	severity = 'C'; break;
		case EVENT_WARNING:		severity = 'W'; break;
		case EVENT_ERROR:		severity = 'E'; break;
		case EVENT_ASSERT:		severity = 'A'; break;
		case EVENT_BOOTUP:		severity = 'B'; break;
		case EVENT_TIMESYNC:	severity = 'T'; break;
	}

	if (exposed->severity == EVENT_TIMESYNC) {
		out = snprintf(output, output_ln,
						"[%c][CNT:%lu][MT:%lu][RTC_TIMESYNC][DATE:%d/%d/%d][TIME:%d:%d:%d]",
						severity,
						exposed->event_counter_id,
						exposed->event_master_time,
						(uint16_t)exposed->param2,
						(uint16_t)exposed->param,
						(uint16_t)exposed->wparam,
						(uint16_t)exposed->wparam2,
						(uint16_t)exposed->lparam,
						(uint16_t)exposed->lparam2);
	}
	else {
		// if pointer to event string is set
		if (variant_validate_is_within_flash((const void*)exposed->event_str_name) == 1) {
			out = snprintf(output, output_ln,
							"[%c][CNT:%lu][MT:%lu][%s][%s][P: %X %X %X %X %lX %lX]",
							severity,
							exposed->event_counter_id,
							exposed->event_master_time,
							exposed->source_str_name,
							exposed->event_str_name,
							exposed->param,
							exposed->param2,
							exposed->wparam,
							exposed->wparam2,
							exposed->lparam,
							exposed->lparam2);
		}
		else {
			out = snprintf(output, output_ln,
							"[%c][CNT:%lu][MT:%lu][%s][EV:%d][P: %X %X %X %X %lX %lX]",
							severity,
							exposed->event_counter_id,
							exposed->event_master_time,
							exposed->source_str_name,
							exposed->event_id,
							exposed->param,
							exposed->param2,
							exposed->wparam,
							exposed->wparam2,
							exposed->lparam,
							exposed->lparam2);
		}
	}


	return out;
}

