   1              		.cpu cortex-m4
   2              		.eabi_attribute 27, 1
   3              		.eabi_attribute 28, 1
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 1
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.file	"wx_handler.c"
  14              		.text
  15              	.Ltext0:
  16              		.cfi_sections	.debug_frame
  17              		.section	.text.wx_check_force_i2c_reset,"ax",%progbits
  18              		.align	1
  19              		.global	wx_check_force_i2c_reset
  20              		.syntax unified
  21              		.thumb
  22              		.thumb_func
  23              		.fpu fpv4-sp-d16
  25              	wx_check_force_i2c_reset:
  26              	.LFB403:
  27              		.file 1 "../src/wx_handler.c"
   1:../src/wx_handler.c **** /*
   2:../src/wx_handler.c ****  * wx_handler.c
   3:../src/wx_handler.c ****  *
   4:../src/wx_handler.c ****  *  Created on: 26.01.2019
   5:../src/wx_handler.c ****  *      Author: mateusz
   6:../src/wx_handler.c ****  */
   7:../src/wx_handler.c **** 
   8:../src/wx_handler.c **** #include "wx_handler.h"
   9:../src/wx_handler.c **** #include "wx_handler_humidity.h"
  10:../src/wx_handler.c **** #include "wx_handler_pressure.h"
  11:../src/wx_handler.c **** #include "wx_handler_temperature.h"
  12:../src/wx_handler.c **** 
  13:../src/wx_handler.c **** #include <rte_wx.h>
  14:../src/wx_handler.c **** #include <rte_rtu.h>
  15:../src/wx_handler.c **** #include <rte_main.h>
  16:../src/wx_handler.c **** #include <math.h>
  17:../src/wx_handler.c **** 
  18:../src/wx_handler.c **** #ifdef STM32F10X_MD_VL
  19:../src/wx_handler.c **** #include <stm32f10x.h>
  20:../src/wx_handler.c **** #endif
  21:../src/wx_handler.c **** 
  22:../src/wx_handler.c **** #ifdef STM32L471xx
  23:../src/wx_handler.c **** #include <stm32l4xx.h>
  24:../src/wx_handler.c **** #include <stm32l4xx_ll_gpio.h>
  25:../src/wx_handler.c **** #endif
  26:../src/wx_handler.c **** #include "drivers/analog_anemometer.h"
  27:../src/wx_handler.c **** 
  28:../src/wx_handler.c **** #include "station_config.h"
  29:../src/wx_handler.c **** 
  30:../src/wx_handler.c **** #include "modbus_rtu/rtu_getters.h"
  31:../src/wx_handler.c **** #include "modbus_rtu/rtu_return_values.h"
  32:../src/wx_handler.c **** 
  33:../src/wx_handler.c **** #include "io.h"
  34:../src/wx_handler.c **** #include "delay.h"
  35:../src/wx_handler.c **** #include "telemetry.h"
  36:../src/wx_handler.c **** #include "main.h"
  37:../src/wx_handler.c **** 
  38:../src/wx_handler.c **** #define WX_WATCHDOG_PERIOD (SYSTICK_TICKS_PER_SECONDS * SYSTICK_TICKS_PERIOD * 90)
  39:../src/wx_handler.c **** #define WX_WATCHDOG_RESET_DURATION (SYSTICK_TICKS_PER_SECONDS * SYSTICK_TICKS_PERIOD * 3)
  40:../src/wx_handler.c **** 
  41:../src/wx_handler.c **** uint32_t wx_last_good_wind_time = 0;
  42:../src/wx_handler.c **** uint32_t wx_last_good_temperature_time = 0;
  43:../src/wx_handler.c **** wx_pwr_state_t wx_pwr_state;
  44:../src/wx_handler.c **** uint32_t wx_wind_pool_call_counter = 0;
  45:../src/wx_handler.c **** uint8_t wx_force_i2c_sensor_reset = 0;
  46:../src/wx_handler.c **** 
  47:../src/wx_handler.c **** static const float direction_constant = M_PI/180.0f;
  48:../src/wx_handler.c **** static const config_data_wx_sources_t internal = {
  49:../src/wx_handler.c **** 		.temperature = WX_SOURCE_INTERNAL,
  50:../src/wx_handler.c **** 		.pressure = WX_SOURCE_INTERNAL,
  51:../src/wx_handler.c **** 		.humidity = WX_SOURCE_INTERNAL,
  52:../src/wx_handler.c **** 		.wind = WX_SOURCE_INTERNAL
  53:../src/wx_handler.c **** };
  54:../src/wx_handler.c **** 
  55:../src/wx_handler.c **** #define MODBUS_QF_TEMPERATURE_FULL		1
  56:../src/wx_handler.c **** #define MODBUS_QF_TEMPERATURE_DEGR		(1 << 1)
  57:../src/wx_handler.c **** #define MODBUS_QF_TEMPERATURE_NAVB		(1 << 2)
  58:../src/wx_handler.c **** #define MODBUS_QF_HUMIDITY_FULL 		(1 << 3)
  59:../src/wx_handler.c **** #define MODBUS_QF_HUMIDITY_DEGR 		(1 << 4)
  60:../src/wx_handler.c **** #define MODBUS_QF_PRESSURE_FULL			(1 << 5)
  61:../src/wx_handler.c **** #define MODBUS_QF_PRESSURE_DEGR			(1 << 6)
  62:../src/wx_handler.c **** 
  63:../src/wx_handler.c **** 
  64:../src/wx_handler.c **** void wx_check_force_i2c_reset(void) {
  28              		.loc 1 64 0
  29              		.cfi_startproc
  30              		@ args = 0, pretend = 0, frame = 0
  31              		@ frame_needed = 0, uses_anonymous_args = 0
  65:../src/wx_handler.c **** 
  66:../src/wx_handler.c **** 	if (wx_force_i2c_sensor_reset == 1) {
  32              		.loc 1 66 0
  33 0000 084B     		ldr	r3, .L8
  34 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  35 0004 012B     		cmp	r3, #1
  36 0006 00D0     		beq	.L7
  37 0008 7047     		bx	lr
  38              	.L7:
  64:../src/wx_handler.c **** 
  39              		.loc 1 64 0
  40 000a 10B5     		push	{r4, lr}
  41              		.cfi_def_cfa_offset 8
  42              		.cfi_offset 4, -8
  43              		.cfi_offset 14, -4
  67:../src/wx_handler.c **** 		wx_force_i2c_sensor_reset = 0;
  44              		.loc 1 67 0
  45 000c 0024     		movs	r4, #0
  46 000e 054B     		ldr	r3, .L8
  47 0010 1C70     		strb	r4, [r3]
  68:../src/wx_handler.c **** 
  69:../src/wx_handler.c **** #if defined (_SENSOR_BME280)
  70:../src/wx_handler.c **** 		 bme280_reset(&rte_wx_bme280_qf);
  71:../src/wx_handler.c **** 		 bme280_setup();
  72:../src/wx_handler.c **** #endif
  73:../src/wx_handler.c **** 
  74:../src/wx_handler.c **** #if defined (_SENSOR_MS5611)
  75:../src/wx_handler.c **** 		 ms5611_reset(&rte_wx_ms5611_qf);
  48              		.loc 1 75 0
  49 0012 0548     		ldr	r0, .L8+4
  50 0014 FFF7FEFF 		bl	ms5611_reset
  51              	.LVL0:
  76:../src/wx_handler.c **** 		 ms5611_trigger_measure(0, 0);
  52              		.loc 1 76 0
  53 0018 2146     		mov	r1, r4
  54 001a 2046     		mov	r0, r4
  55 001c FFF7FEFF 		bl	ms5611_trigger_measure
  56              	.LVL1:
  77:../src/wx_handler.c **** #endif
  78:../src/wx_handler.c **** 	}
  79:../src/wx_handler.c **** 
  80:../src/wx_handler.c **** }
  57              		.loc 1 80 0
  58 0020 10BD     		pop	{r4, pc}
  59              	.L9:
  60 0022 00BF     		.align	2
  61              	.L8:
  62 0024 00000000 		.word	.LANCHOR0
  63 0028 00000000 		.word	rte_wx_ms5611_qf
  64              		.cfi_endproc
  65              	.LFE403:
  67              		.section	.text.wx_get_all_measurements,"ax",%progbits
  68              		.align	1
  69              		.global	wx_get_all_measurements
  70              		.syntax unified
  71              		.thumb
  72              		.thumb_func
  73              		.fpu fpv4-sp-d16
  75              	wx_get_all_measurements:
  76              	.LFB404:
  81:../src/wx_handler.c **** 
  82:../src/wx_handler.c **** void wx_get_all_measurements(const config_data_wx_sources_t * const config_sources, const config_da
  77              		.loc 1 82 0
  78              		.cfi_startproc
  79              		@ args = 0, pretend = 0, frame = 0
  80              		@ frame_needed = 0, uses_anonymous_args = 0
  81              	.LVL2:
  82 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  83              		.cfi_def_cfa_offset 24
  84              		.cfi_offset 4, -24
  85              		.cfi_offset 5, -20
  86              		.cfi_offset 6, -16
  87              		.cfi_offset 7, -12
  88              		.cfi_offset 8, -8
  89              		.cfi_offset 14, -4
  90 0004 0546     		mov	r5, r0
  91 0006 0E46     		mov	r6, r1
  92 0008 1746     		mov	r7, r2
  93 000a 9846     		mov	r8, r3
  94              	.LVL3:
  83:../src/wx_handler.c **** 
  84:../src/wx_handler.c **** 	int32_t parameter_result = 0;						// stores which parameters have been retrieved successfully. th
  85:../src/wx_handler.c **** 	int32_t backup_parameter_result = 0;				// uses during retrieving backup
  86:../src/wx_handler.c **** 
  87:../src/wx_handler.c **** 	parameter_result |= wx_get_temperature_measurement(config_sources, config_mode, config_umb, config
  95              		.loc 1 87 0
  96 000c FFF7FEFF 		bl	wx_get_temperature_measurement
  97              	.LVL4:
  98 0010 0446     		mov	r4, r0
  99              	.LVL5:
  88:../src/wx_handler.c **** 	parameter_result |= wx_get_pressure_measurement(config_sources, config_mode, config_umb, config_rt
 100              		.loc 1 88 0
 101 0012 4346     		mov	r3, r8
 102 0014 3A46     		mov	r2, r7
 103 0016 3146     		mov	r1, r6
 104 0018 2846     		mov	r0, r5
 105              	.LVL6:
 106 001a FFF7FEFF 		bl	wx_get_pressure_measurement
 107              	.LVL7:
 108 001e 0443     		orrs	r4, r4, r0
 109              	.LVL8:
  89:../src/wx_handler.c **** 	parameter_result |= wx_get_humidity_measurement(config_sources, config_mode, config_umb, config_rt
 110              		.loc 1 89 0
 111 0020 4346     		mov	r3, r8
 112 0022 3A46     		mov	r2, r7
 113 0024 3146     		mov	r1, r6
 114 0026 2846     		mov	r0, r5
 115 0028 FFF7FEFF 		bl	wx_get_humidity_measurement
 116              	.LVL9:
 117 002c 0443     		orrs	r4, r4, r0
 118              	.LVL10:
  90:../src/wx_handler.c **** 
  91:../src/wx_handler.c **** 	// check if all parameters (except wind) were collected successfully
  92:../src/wx_handler.c **** 	if (parameter_result == (WX_HANDLER_PARAMETER_RESULT_TEMPERATURE | WX_HANDLER_PARAMETER_RESULT_PRE
 119              		.loc 1 92 0
 120 002e 2E2C     		cmp	r4, #46
 121 0030 17D0     		beq	.L10
  93:../src/wx_handler.c **** 		;	// if everything were OK do nothing
  94:../src/wx_handler.c **** 	}
  95:../src/wx_handler.c **** 	else {
  96:../src/wx_handler.c **** 		// if not check what was faulty and backup with an internal sensor
  97:../src/wx_handler.c **** 		if ((parameter_result & WX_HANDLER_PARAMETER_RESULT_TEMPERATURE) == 0) {
 122              		.loc 1 97 0
 123 0032 14F0020F 		tst	r4, #2
 124 0036 02D1     		bne	.L12
  98:../src/wx_handler.c **** 			// if we don't have temperature
  99:../src/wx_handler.c **** 			// check what is the primary source of temperature
 100:../src/wx_handler.c **** 			if (config_sources->temperature != WX_SOURCE_INTERNAL) {
 125              		.loc 1 100 0
 126 0038 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 127 003a 012B     		cmp	r3, #1
 128 003c 13D1     		bne	.L15
 129              	.LVL11:
 130              	.L12:
 101:../src/wx_handler.c **** 				// if this is something different than an internal source use the internal sensor
 102:../src/wx_handler.c **** 				backup_parameter_result |= wx_get_temperature_measurement(&internal, config_mode, config_umb, c
 103:../src/wx_handler.c **** 			}
 104:../src/wx_handler.c **** 			else {
 105:../src/wx_handler.c **** 				; //
 106:../src/wx_handler.c **** 			}
 107:../src/wx_handler.c **** 		}
 108:../src/wx_handler.c **** 
 109:../src/wx_handler.c **** 		if ((parameter_result & WX_HANDLER_PARAMETER_RESULT_PRESSURE) == 0) {
 131              		.loc 1 109 0
 132 003e 14F0040F 		tst	r4, #4
 133 0042 02D1     		bne	.L13
 110:../src/wx_handler.c **** 
 111:../src/wx_handler.c **** 			if (config_sources->pressure != WX_SOURCE_INTERNAL) {
 134              		.loc 1 111 0
 135 0044 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 136 0046 012B     		cmp	r3, #1
 137 0048 14D1     		bne	.L16
 138              	.L13:
 112:../src/wx_handler.c **** 				backup_parameter_result |= wx_get_pressure_measurement(&internal, config_mode, config_umb, conf
 113:../src/wx_handler.c **** 			}
 114:../src/wx_handler.c **** 		}
 115:../src/wx_handler.c **** 
 116:../src/wx_handler.c **** 		if ((parameter_result & WX_HANDLER_PARAMETER_RESULT_HUMIDITY) == 0) {
 139              		.loc 1 116 0
 140 004a 14F0080F 		tst	r4, #8
 141 004e 08D1     		bne	.L10
 117:../src/wx_handler.c **** 
 118:../src/wx_handler.c **** 			if (config_sources->pressure != WX_SOURCE_INTERNAL) {
 142              		.loc 1 118 0
 143 0050 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 144 0052 012B     		cmp	r3, #1
 145 0054 05D0     		beq	.L10
 119:../src/wx_handler.c **** 				backup_parameter_result |= wx_get_humidity_measurement(&internal, config_mode, config_umb, conf
 146              		.loc 1 119 0
 147 0056 4346     		mov	r3, r8
 148 0058 3A46     		mov	r2, r7
 149 005a 3146     		mov	r1, r6
 150 005c 0948     		ldr	r0, .L17
 151 005e FFF7FEFF 		bl	wx_get_humidity_measurement
 152              	.LVL12:
 153              	.L10:
 120:../src/wx_handler.c **** 			}
 121:../src/wx_handler.c **** 		}
 122:../src/wx_handler.c **** 	}
 123:../src/wx_handler.c **** 
 124:../src/wx_handler.c **** 
 125:../src/wx_handler.c **** }
 154              		.loc 1 125 0
 155 0062 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 156              	.LVL13:
 157              	.L15:
 102:../src/wx_handler.c **** 			}
 158              		.loc 1 102 0
 159 0066 4346     		mov	r3, r8
 160 0068 3A46     		mov	r2, r7
 161 006a 3146     		mov	r1, r6
 162 006c 0548     		ldr	r0, .L17
 163 006e FFF7FEFF 		bl	wx_get_temperature_measurement
 164              	.LVL14:
 165 0072 E4E7     		b	.L12
 166              	.L16:
 112:../src/wx_handler.c **** 			}
 167              		.loc 1 112 0
 168 0074 4346     		mov	r3, r8
 169 0076 3A46     		mov	r2, r7
 170 0078 3146     		mov	r1, r6
 171 007a 0248     		ldr	r0, .L17
 172 007c FFF7FEFF 		bl	wx_get_pressure_measurement
 173              	.LVL15:
 174 0080 E3E7     		b	.L13
 175              	.L18:
 176 0082 00BF     		.align	2
 177              	.L17:
 178 0084 00000000 		.word	.LANCHOR1
 179              		.cfi_endproc
 180              	.LFE404:
 182              		.section	.text.wx_get_bme280_temperature_pressure_humidity,"ax",%progbits
 183              		.align	1
 184              		.global	wx_get_bme280_temperature_pressure_humidity
 185              		.syntax unified
 186              		.thumb
 187              		.thumb_func
 188              		.fpu fpv4-sp-d16
 190              	wx_get_bme280_temperature_pressure_humidity:
 191              	.LFB405:
 126:../src/wx_handler.c **** 
 127:../src/wx_handler.c **** 
 128:../src/wx_handler.c **** 
 129:../src/wx_handler.c **** int32_t wx_get_bme280_temperature_pressure_humidity(float * const temperature, float * const pressu
 192              		.loc 1 129 0
 193              		.cfi_startproc
 194              		@ args = 0, pretend = 0, frame = 0
 195              		@ frame_needed = 0, uses_anonymous_args = 0
 196              	.LVL16:
 197 0000 08B5     		push	{r3, lr}
 198              		.cfi_def_cfa_offset 8
 199              		.cfi_offset 3, -8
 200              		.cfi_offset 14, -4
 201              	.LVL17:
 130:../src/wx_handler.c **** 
 131:../src/wx_handler.c **** 	int32_t return_value = 0;
 132:../src/wx_handler.c **** 
 133:../src/wx_handler.c **** 	// reading raw values from BME280 sensor
 134:../src/wx_handler.c **** 	return_value = bme280_read_raw_data(bme280_data_buffer);
 202              		.loc 1 134 0
 203 0002 0748     		ldr	r0, .L24
 204              	.LVL18:
 205 0004 FFF7FEFF 		bl	bme280_read_raw_data
 206              	.LVL19:
 135:../src/wx_handler.c **** 
 136:../src/wx_handler.c **** 	if (return_value == BME280_OK) {
 207              		.loc 1 136 0
 208 0008 0346     		mov	r3, r0
 209 000a 20B1     		cbz	r0, .L23
 137:../src/wx_handler.c **** 
 138:../src/wx_handler.c **** 		// setting back the Quality Factor to FULL to trace any problems with sensor readouts
 139:../src/wx_handler.c **** 		rte_wx_bme280_qf = BME280_QF_FULL;
 140:../src/wx_handler.c **** 
 141:../src/wx_handler.c **** 		// converting raw values to temperature
 142:../src/wx_handler.c **** 		//bme280_get_temperature(temperature, bme280_get_adc_t(), &rte_wx_bme280_qf);
 143:../src/wx_handler.c **** 
 144:../src/wx_handler.c **** 		// if modbus RTU is enabled but the quality factor for RTU-pressure is set to NOT_AVALIABLE
 145:../src/wx_handler.c **** 		//bme280_get_pressure(pressure, bme280_get_adc_p(), &rte_wx_bme280_qf);
 146:../src/wx_handler.c **** 
 147:../src/wx_handler.c **** 		// if modbus RTU is enabled but the quality factor for RTU-humidity is set to NOT_AVALIABLE
 148:../src/wx_handler.c **** 		//bme280_get_humidity(humidity, bme280_get_adc_h(), &rte_wx_bme280_qf);
 149:../src/wx_handler.c **** 
 150:../src/wx_handler.c **** 	}
 151:../src/wx_handler.c **** 	else {
 152:../src/wx_handler.c **** 		// set the quality factor is sensor is not responding on the i2c bus
 153:../src/wx_handler.c **** 		rte_wx_bme280_qf = BME280_QF_NOT_AVAILABLE;
 210              		.loc 1 153 0
 211 000c 054A     		ldr	r2, .L24+4
 212 000e 0121     		movs	r1, #1
 213 0010 1170     		strb	r1, [r2]
 214              	.L19:
 154:../src/wx_handler.c **** 	}
 155:../src/wx_handler.c **** 
 156:../src/wx_handler.c **** 	return return_value;
 157:../src/wx_handler.c **** }
 215              		.loc 1 157 0
 216 0012 1846     		mov	r0, r3
 217              	.LVL20:
 218 0014 08BD     		pop	{r3, pc}
 219              	.LVL21:
 220              	.L23:
 139:../src/wx_handler.c **** 
 221              		.loc 1 139 0
 222 0016 034A     		ldr	r2, .L24+4
 223 0018 0021     		movs	r1, #0
 224 001a 1170     		strb	r1, [r2]
 225 001c F9E7     		b	.L19
 226              	.L25:
 227 001e 00BF     		.align	2
 228              	.L24:
 229 0020 00000000 		.word	bme280_data_buffer
 230 0024 00000000 		.word	rte_wx_bme280_qf
 231              		.cfi_endproc
 232              	.LFE405:
 234              		.global	__aeabi_f2d
 235              		.global	__aeabi_dmul
 236              		.global	__aeabi_d2iz
 237              		.section	.text.wx_pool_anemometer,"ax",%progbits
 238              		.align	1
 239              		.global	wx_pool_anemometer
 240              		.syntax unified
 241              		.thumb
 242              		.thumb_func
 243              		.fpu fpv4-sp-d16
 245              	wx_pool_anemometer:
 246              	.LFB406:
 158:../src/wx_handler.c **** 
 159:../src/wx_handler.c **** 
 160:../src/wx_handler.c **** void wx_pool_anemometer(const config_data_wx_sources_t * const config_sources, const config_data_mo
 247              		.loc 1 160 0
 248              		.cfi_startproc
 249              		@ args = 0, pretend = 0, frame = 16
 250              		@ frame_needed = 0, uses_anonymous_args = 0
 251              	.LVL22:
 252 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 253              		.cfi_def_cfa_offset 36
 254              		.cfi_offset 4, -36
 255              		.cfi_offset 5, -32
 256              		.cfi_offset 6, -28
 257              		.cfi_offset 7, -24
 258              		.cfi_offset 8, -20
 259              		.cfi_offset 9, -16
 260              		.cfi_offset 10, -12
 261              		.cfi_offset 11, -8
 262              		.cfi_offset 14, -4
 263 0004 2DED028B 		vpush.64	{d8}
 264              		.cfi_def_cfa_offset 44
 265              		.cfi_offset 80, -44
 266              		.cfi_offset 81, -40
 267 0008 85B0     		sub	sp, sp, #20
 268              		.cfi_def_cfa_offset 64
 269 000a 8146     		mov	r9, r0
 270 000c 8B46     		mov	fp, r1
 271 000e 1446     		mov	r4, r2
 272 0010 1D46     		mov	r5, r3
 273              	.LVL23:
 161:../src/wx_handler.c **** 
 162:../src/wx_handler.c **** 	// locals
 163:../src/wx_handler.c **** 	uint32_t average_windspeed = 0;
 164:../src/wx_handler.c **** 	int32_t wind_direction_x_avg = 0;
 165:../src/wx_handler.c **** 	int32_t wind_direction_y_avg = 0;
 166:../src/wx_handler.c **** 	int16_t wind_direction_x = 0;
 167:../src/wx_handler.c **** 	int16_t wind_direction_y = 0;
 168:../src/wx_handler.c **** 	volatile float dir_temp = 0;
 274              		.loc 1 168 0
 275 0012 0023     		movs	r3, #0
 276              	.LVL24:
 277 0014 0393     		str	r3, [sp, #12]	@ float
 169:../src/wx_handler.c **** 	volatile float arctan_value = 0.0f;
 278              		.loc 1 169 0
 279 0016 0293     		str	r3, [sp, #8]	@ float
 280              	.LVL25:
 170:../src/wx_handler.c **** 	short i = 0;
 171:../src/wx_handler.c **** 	uint8_t average_ln;
 172:../src/wx_handler.c **** 
 173:../src/wx_handler.c **** 	int32_t modbus_retval;
 174:../src/wx_handler.c **** 
 175:../src/wx_handler.c **** 	wx_wind_pool_call_counter++;
 281              		.loc 1 175 0
 282 0018 934A     		ldr	r2, .L66+8
 283              	.LVL26:
 284 001a 1368     		ldr	r3, [r2]
 285 001c 0133     		adds	r3, r3, #1
 286 001e 1360     		str	r3, [r2]
 176:../src/wx_handler.c **** 
 177:../src/wx_handler.c **** 	uint16_t scaled_windspeed = 0;
 287              		.loc 1 177 0
 288 0020 0023     		movs	r3, #0
 289 0022 ADF80630 		strh	r3, [sp, #6]	@ movhi
 178:../src/wx_handler.c **** 
 179:../src/wx_handler.c **** 	// internal sensors
 180:../src/wx_handler.c **** 	if (config_sources->wind == WX_SOURCE_INTERNAL) {
 290              		.loc 1 180 0
 291 0026 C378     		ldrb	r3, [r0, #3]	@ zero_extendqisi2
 292 0028 012B     		cmp	r3, #1
 293 002a 21D0     		beq	.L55
 181:../src/wx_handler.c **** 		// this windspeed is scaled * 10. Example: 0.2 meters per second is stored as 2
 182:../src/wx_handler.c **** 		scaled_windspeed = analog_anemometer_get_ms_from_pulse(rte_wx_windspeed_pulses);
 183:../src/wx_handler.c **** 	}
 184:../src/wx_handler.c **** 
 185:../src/wx_handler.c **** 	else if (config_sources->wind == WX_SOURCE_UMB) {
 294              		.loc 1 185 0
 295 002c 022B     		cmp	r3, #2
 296 002e 26D0     		beq	.L56
 186:../src/wx_handler.c **** 		rte_wx_average_winddirection = umb_get_winddirection(config_umb);
 187:../src/wx_handler.c **** 		rte_wx_average_windspeed = umb_get_windspeed(config_umb);
 188:../src/wx_handler.c **** 		rte_wx_max_windspeed = umb_get_windgusts(config_umb);
 189:../src/wx_handler.c **** 	}
 190:../src/wx_handler.c **** 
 191:../src/wx_handler.c **** 	else if (config_sources->wind == WX_SOURCE_RTU) {
 297              		.loc 1 191 0
 298 0030 032B     		cmp	r3, #3
 299 0032 34D0     		beq	.L57
 192:../src/wx_handler.c **** 		// get the value from modbus registers
 193:../src/wx_handler.c **** 		modbus_retval = rtu_get_wind_speed(&scaled_windspeed, config_rtu);
 194:../src/wx_handler.c **** 
 195:../src/wx_handler.c **** 		// check if this value has been processed w/o errors
 196:../src/wx_handler.c **** 		if (modbus_retval == MODBUS_RET_OK) {
 197:../src/wx_handler.c **** 			// if yes continue to further processing
 198:../src/wx_handler.c **** 			modbus_retval = rtu_get_wind_direction(&rte_wx_winddirection_last, config_rtu);
 199:../src/wx_handler.c **** 
 200:../src/wx_handler.c **** 		}
 201:../src/wx_handler.c **** 
 202:../src/wx_handler.c **** 		// the second IF to check if the return value was the same for wind direction
 203:../src/wx_handler.c **** 		if (modbus_retval == MODBUS_RET_OK || modbus_retval == MODBUS_RET_DEGRADED) {
 204:../src/wx_handler.c **** 			// if the value is not available (like modbus is not configured as a source
 205:../src/wx_handler.c **** 			// for wind data) get the value from internal sensors..
 206:../src/wx_handler.c **** 			#ifdef _INTERNAL_AS_BACKUP
 207:../src/wx_handler.c **** 				// .. if they are configured
 208:../src/wx_handler.c **** 				scaled_windspeed = analog_anemometer_get_ms_from_pulse(rte_wx_windspeed_pulses);
 209:../src/wx_handler.c **** 			#endif
 210:../src/wx_handler.c **** 		}
 211:../src/wx_handler.c **** 	}
 212:../src/wx_handler.c **** 
 213:../src/wx_handler.c **** 	else if (config_sources->wind == WX_SOURCE_FULL_RTU) {
 300              		.loc 1 213 0
 301 0034 042B     		cmp	r3, #4
 302 0036 4CD0     		beq	.L58
 303              	.LVL27:
 304              	.L28:
 214:../src/wx_handler.c **** 		// get the value from modbus registers
 215:../src/wx_handler.c **** 		modbus_retval = rtu_get_wind_direction(&rte_wx_average_winddirection, config_rtu);
 216:../src/wx_handler.c **** 
 217:../src/wx_handler.c **** 		// check if this value has been processed w/o errors
 218:../src/wx_handler.c **** 		if (modbus_retval == MODBUS_RET_OK || modbus_retval == MODBUS_RET_DEGRADED) {
 219:../src/wx_handler.c **** 			// if yes continue to further processing
 220:../src/wx_handler.c **** 			modbus_retval = rtu_get_wind_gusts(&rte_wx_max_windspeed, config_rtu);
 221:../src/wx_handler.c **** 			modbus_retval = rtu_get_wind_speed(&rte_wx_winddirection_last, config_rtu);
 222:../src/wx_handler.c **** 
 223:../src/wx_handler.c **** 		}
 224:../src/wx_handler.c **** 	}
 225:../src/wx_handler.c **** 	else {
 226:../src/wx_handler.c **** 		;
 227:../src/wx_handler.c **** 	}
 228:../src/wx_handler.c **** 
 229:../src/wx_handler.c **** 	if (config_sources->wind != WX_SOURCE_FULL_RTU) {
 305              		.loc 1 229 0
 306 0038 99F80330 		ldrb	r3, [r9, #3]	@ zero_extendqisi2
 307 003c 042B     		cmp	r3, #4
 308 003e 00F0D680 		beq	.L34
 230:../src/wx_handler.c **** 		// check how many times before the pool function was called
 231:../src/wx_handler.c **** 		if (wx_wind_pool_call_counter < WIND_AVERAGE_LEN) {
 309              		.loc 1 231 0
 310 0042 894B     		ldr	r3, .L66+8
 311 0044 1A68     		ldr	r2, [r3]
 312 0046 112A     		cmp	r2, #17
 313 0048 55D8     		bhi	.L52
 232:../src/wx_handler.c **** 			// if it was called less time than a length of buffers, the average length
 233:../src/wx_handler.c **** 			// needs to be shortened to handle the underrun properly
 234:../src/wx_handler.c **** 			average_ln = (uint8_t)wx_wind_pool_call_counter;
 314              		.loc 1 234 0
 315 004a D2B2     		uxtb	r2, r2
 316              	.LVL28:
 317              	.L35:
 235:../src/wx_handler.c **** 		}
 236:../src/wx_handler.c **** 		else {
 237:../src/wx_handler.c **** 			average_ln = WIND_AVERAGE_LEN;
 238:../src/wx_handler.c **** 		}
 239:../src/wx_handler.c **** 
 240:../src/wx_handler.c **** 		// putting the wind speed into circular buffer
 241:../src/wx_handler.c **** 		rte_wx_windspeed[rte_wx_windspeed_it] = scaled_windspeed;
 318              		.loc 1 241 0
 319 004c 8749     		ldr	r1, .L66+12
 320 004e 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 321 0050 8748     		ldr	r0, .L66+16
 322 0052 BDF80640 		ldrh	r4, [sp, #6]
 323              	.LVL29:
 324 0056 20F81340 		strh	r4, [r0, r3, lsl #1]	@ movhi
 242:../src/wx_handler.c **** 
 243:../src/wx_handler.c **** 		// increasing the iterator to the windspeed buffer
 244:../src/wx_handler.c **** 		rte_wx_windspeed_it++;
 325              		.loc 1 244 0
 326 005a 0133     		adds	r3, r3, #1
 327 005c DBB2     		uxtb	r3, r3
 328 005e 0B70     		strb	r3, [r1]
 245:../src/wx_handler.c **** 
 246:../src/wx_handler.c **** 		// checking if iterator reached an end of the buffer
 247:../src/wx_handler.c **** 		if (rte_wx_windspeed_it >= WIND_AVERAGE_LEN) {
 329              		.loc 1 247 0
 330 0060 112B     		cmp	r3, #17
 331 0062 02D9     		bls	.L36
 248:../src/wx_handler.c **** 			rte_wx_windspeed_it = 0;
 332              		.loc 1 248 0
 333 0064 0B46     		mov	r3, r1
 334 0066 0021     		movs	r1, #0
 335 0068 1970     		strb	r1, [r3]
 336              	.L36:
 249:../src/wx_handler.c **** 		}
 250:../src/wx_handler.c **** 
 251:../src/wx_handler.c **** 		// calculating the average windspeed
 252:../src/wx_handler.c **** 		for (i = 0; i < average_ln; i++)
 337              		.loc 1 252 0
 338 006a 0023     		movs	r3, #0
 163:../src/wx_handler.c **** 	int32_t wind_direction_x_avg = 0;
 339              		.loc 1 163 0
 340 006c 1946     		mov	r1, r3
 341              		.loc 1 252 0
 342 006e 4AE0     		b	.L37
 343              	.LVL30:
 344              	.L55:
 182:../src/wx_handler.c **** 	}
 345              		.loc 1 182 0
 346 0070 804B     		ldr	r3, .L66+20
 347 0072 1888     		ldrh	r0, [r3]
 348              	.LVL31:
 349 0074 FFF7FEFF 		bl	analog_anemometer_get_ms_from_pulse
 350              	.LVL32:
 351 0078 ADF80600 		strh	r0, [sp, #6]	@ movhi
 352 007c DCE7     		b	.L28
 353              	.LVL33:
 354              	.L56:
 186:../src/wx_handler.c **** 		rte_wx_average_windspeed = umb_get_windspeed(config_umb);
 355              		.loc 1 186 0
 356 007e 2046     		mov	r0, r4
 357              	.LVL34:
 358 0080 FFF7FEFF 		bl	umb_get_winddirection
 359              	.LVL35:
 360 0084 7C4B     		ldr	r3, .L66+24
 361 0086 1880     		strh	r0, [r3]	@ movhi
 187:../src/wx_handler.c **** 		rte_wx_max_windspeed = umb_get_windgusts(config_umb);
 362              		.loc 1 187 0
 363 0088 2046     		mov	r0, r4
 364 008a FFF7FEFF 		bl	umb_get_windspeed
 365              	.LVL36:
 366 008e 7B4B     		ldr	r3, .L66+28
 367 0090 1880     		strh	r0, [r3]	@ movhi
 188:../src/wx_handler.c **** 	}
 368              		.loc 1 188 0
 369 0092 2046     		mov	r0, r4
 370 0094 FFF7FEFF 		bl	umb_get_windgusts
 371              	.LVL37:
 372 0098 794B     		ldr	r3, .L66+32
 373 009a 1880     		strh	r0, [r3]	@ movhi
 374 009c CCE7     		b	.L28
 375              	.LVL38:
 376              	.L57:
 193:../src/wx_handler.c **** 
 377              		.loc 1 193 0
 378 009e 2946     		mov	r1, r5
 379              	.LVL39:
 380 00a0 0DF10600 		add	r0, sp, #6
 381              	.LVL40:
 382 00a4 FFF7FEFF 		bl	rtu_get_wind_speed
 383              	.LVL41:
 196:../src/wx_handler.c **** 			// if yes continue to further processing
 384              		.loc 1 196 0
 385 00a8 8246     		mov	r10, r0
 386 00aa 60B1     		cbz	r0, .L59
 387              	.L31:
 203:../src/wx_handler.c **** 			// if the value is not available (like modbus is not configured as a source
 388              		.loc 1 203 0
 389 00ac BAF1000F 		cmp	r10, #0
 390 00b0 02D0     		beq	.L32
 203:../src/wx_handler.c **** 			// if the value is not available (like modbus is not configured as a source
 391              		.loc 1 203 0 is_stmt 0 discriminator 1
 392 00b2 BAF1060F 		cmp	r10, #6
 393 00b6 BFD1     		bne	.L28
 394              	.L32:
 208:../src/wx_handler.c **** 			#endif
 395              		.loc 1 208 0 is_stmt 1
 396 00b8 6E4B     		ldr	r3, .L66+20
 397 00ba 1888     		ldrh	r0, [r3]
 398              	.LVL42:
 399 00bc FFF7FEFF 		bl	analog_anemometer_get_ms_from_pulse
 400              	.LVL43:
 401 00c0 ADF80600 		strh	r0, [sp, #6]	@ movhi
 402 00c4 B8E7     		b	.L28
 403              	.LVL44:
 404              	.L59:
 198:../src/wx_handler.c **** 
 405              		.loc 1 198 0
 406 00c6 2946     		mov	r1, r5
 407 00c8 6E48     		ldr	r0, .L66+36
 408              	.LVL45:
 409 00ca FFF7FEFF 		bl	rtu_get_wind_direction
 410              	.LVL46:
 411 00ce 8246     		mov	r10, r0
 412              	.LVL47:
 413 00d0 ECE7     		b	.L31
 414              	.LVL48:
 415              	.L58:
 215:../src/wx_handler.c **** 
 416              		.loc 1 215 0
 417 00d2 2946     		mov	r1, r5
 418              	.LVL49:
 419 00d4 6848     		ldr	r0, .L66+24
 420              	.LVL50:
 421 00d6 FFF7FEFF 		bl	rtu_get_wind_direction
 422              	.LVL51:
 218:../src/wx_handler.c **** 			// if yes continue to further processing
 423              		.loc 1 218 0
 424 00da 8246     		mov	r10, r0
 425 00dc 08B1     		cbz	r0, .L33
 218:../src/wx_handler.c **** 			// if yes continue to further processing
 426              		.loc 1 218 0 is_stmt 0 discriminator 1
 427 00de 0628     		cmp	r0, #6
 428 00e0 AAD1     		bne	.L28
 429              	.L33:
 220:../src/wx_handler.c **** 			modbus_retval = rtu_get_wind_speed(&rte_wx_winddirection_last, config_rtu);
 430              		.loc 1 220 0 is_stmt 1
 431 00e2 2946     		mov	r1, r5
 432 00e4 6648     		ldr	r0, .L66+32
 433              	.LVL52:
 434 00e6 FFF7FEFF 		bl	rtu_get_wind_gusts
 435              	.LVL53:
 221:../src/wx_handler.c **** 
 436              		.loc 1 221 0
 437 00ea 2946     		mov	r1, r5
 438 00ec 6548     		ldr	r0, .L66+36
 439 00ee FFF7FEFF 		bl	rtu_get_wind_speed
 440              	.LVL54:
 441 00f2 8246     		mov	r10, r0
 442              	.LVL55:
 443 00f4 A0E7     		b	.L28
 444              	.LVL56:
 445              	.L52:
 237:../src/wx_handler.c **** 		}
 446              		.loc 1 237 0
 447 00f6 1222     		movs	r2, #18
 448 00f8 A8E7     		b	.L35
 449              	.LVL57:
 450              	.L38:
 253:../src/wx_handler.c **** 			average_windspeed += rte_wx_windspeed[i];
 451              		.loc 1 253 0 discriminator 3
 452 00fa 5D48     		ldr	r0, .L66+16
 453 00fc 30F81300 		ldrh	r0, [r0, r3, lsl #1]
 454 0100 0144     		add	r1, r1, r0
 455              	.LVL58:
 252:../src/wx_handler.c **** 			average_windspeed += rte_wx_windspeed[i];
 456              		.loc 1 252 0 discriminator 3
 457 0102 0133     		adds	r3, r3, #1
 458              	.LVL59:
 459 0104 1BB2     		sxth	r3, r3
 460              	.LVL60:
 461              	.L37:
 252:../src/wx_handler.c **** 			average_windspeed += rte_wx_windspeed[i];
 462              		.loc 1 252 0 is_stmt 0 discriminator 1
 463 0106 1646     		mov	r6, r2
 464 0108 9342     		cmp	r3, r2
 465 010a F6DB     		blt	.L38
 254:../src/wx_handler.c **** 
 255:../src/wx_handler.c **** 		average_windspeed /= average_ln;
 466              		.loc 1 255 0 is_stmt 1
 467 010c B1FBF2F2 		udiv	r2, r1, r2
 468              	.LVL61:
 256:../src/wx_handler.c **** 
 257:../src/wx_handler.c **** 		// store the value in rte
 258:../src/wx_handler.c **** 		rte_wx_average_windspeed = average_windspeed;
 469              		.loc 1 258 0
 470 0110 5A4B     		ldr	r3, .L66+28
 471              	.LVL62:
 472 0112 1A80     		strh	r2, [r3]	@ movhi
 473              	.LVL63:
 259:../src/wx_handler.c **** 
 260:../src/wx_handler.c **** 		// reuse the local variable to find maximum value
 261:../src/wx_handler.c **** 		average_windspeed = 0;
 262:../src/wx_handler.c **** 
 263:../src/wx_handler.c **** 		// looking for gusts
 264:../src/wx_handler.c **** 		for (i = 0; i < average_ln; i++) {
 474              		.loc 1 264 0
 475 0114 0023     		movs	r3, #0
 261:../src/wx_handler.c **** 
 476              		.loc 1 261 0
 477 0116 1946     		mov	r1, r3
 478              		.loc 1 264 0
 479 0118 01E0     		b	.L39
 480              	.LVL64:
 481              	.L40:
 482              		.loc 1 264 0 is_stmt 0 discriminator 2
 483 011a 0133     		adds	r3, r3, #1
 484              	.LVL65:
 485 011c 1BB2     		sxth	r3, r3
 486              	.LVL66:
 487              	.L39:
 488              		.loc 1 264 0 discriminator 1
 489 011e 9E42     		cmp	r6, r3
 490 0120 06DD     		ble	.L60
 265:../src/wx_handler.c **** 			if (average_windspeed < rte_wx_windspeed[i])
 491              		.loc 1 265 0 is_stmt 1
 492 0122 534A     		ldr	r2, .L66+16
 493 0124 32F81320 		ldrh	r2, [r2, r3, lsl #1]
 494 0128 8A42     		cmp	r2, r1
 495 012a F6D9     		bls	.L40
 266:../src/wx_handler.c **** 				average_windspeed = rte_wx_windspeed[i];
 496              		.loc 1 266 0
 497 012c 1146     		mov	r1, r2
 498              	.LVL67:
 499 012e F4E7     		b	.L40
 500              	.LVL68:
 501              	.L60:
 267:../src/wx_handler.c **** 		}
 268:../src/wx_handler.c **** 
 269:../src/wx_handler.c **** 		// storing wind gusts value in rte
 270:../src/wx_handler.c **** 		rte_wx_max_windspeed = average_windspeed;
 502              		.loc 1 270 0
 503 0130 534B     		ldr	r3, .L66+32
 504              	.LVL69:
 505 0132 1980     		strh	r1, [r3]	@ movhi
 271:../src/wx_handler.c **** 
 272:../src/wx_handler.c **** 		// adding last wind direction to the buffers
 273:../src/wx_handler.c **** 		if (rte_wx_winddirection_it >= WIND_AVERAGE_LEN)
 506              		.loc 1 273 0
 507 0134 544B     		ldr	r3, .L66+40
 508 0136 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 509 0138 112B     		cmp	r3, #17
 510 013a 02D9     		bls	.L42
 274:../src/wx_handler.c **** 			rte_wx_winddirection_it = 0;
 511              		.loc 1 274 0
 512 013c 524B     		ldr	r3, .L66+40
 513 013e 0022     		movs	r2, #0
 514 0140 1A70     		strb	r2, [r3]
 515              	.L42:
 275:../src/wx_handler.c **** 
 276:../src/wx_handler.c **** 		rte_wx_winddirection[rte_wx_winddirection_it++] = rte_wx_winddirection_last;
 516              		.loc 1 276 0
 517 0142 514A     		ldr	r2, .L66+40
 518 0144 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 519 0146 591C     		adds	r1, r3, #1
 520              	.LVL70:
 521 0148 1170     		strb	r1, [r2]
 522 014a 4E4A     		ldr	r2, .L66+36
 523 014c 1188     		ldrh	r1, [r2]
 524 014e 4F4A     		ldr	r2, .L66+44
 525 0150 22F81310 		strh	r1, [r2, r3, lsl #1]	@ movhi
 526              	.LVL71:
 277:../src/wx_handler.c **** 
 278:../src/wx_handler.c **** 		// calculating average wind direction
 279:../src/wx_handler.c **** 		for (i = 0; i < average_ln; i++) {
 527              		.loc 1 279 0
 528 0154 0024     		movs	r4, #0
 165:../src/wx_handler.c **** 	int16_t wind_direction_x = 0;
 529              		.loc 1 165 0
 530 0156 2746     		mov	r7, r4
 164:../src/wx_handler.c **** 	int32_t wind_direction_y_avg = 0;
 531              		.loc 1 164 0
 532 0158 A046     		mov	r8, r4
 533              		.loc 1 279 0
 534 015a 2AE0     		b	.L43
 535              	.LVL72:
 536              	.L44:
 280:../src/wx_handler.c **** 
 281:../src/wx_handler.c **** 			dir_temp = (float)rte_wx_winddirection[i];
 537              		.loc 1 281 0 discriminator 3
 538 015c 4B4B     		ldr	r3, .L66+44
 539 015e 33F81430 		ldrh	r3, [r3, r4, lsl #1]
 540 0162 07EE903A 		vmov	s15, r3	@ int
 541 0166 F8EE677A 		vcvt.f32.u32	s15, s15
 542 016a CDED037A 		vstr.32	s15, [sp, #12]
 282:../src/wx_handler.c **** 
 283:../src/wx_handler.c **** 			// split the wind direction into x and y component
 284:../src/wx_handler.c **** 			wind_direction_x = (int16_t)(100.0f * cosf(dir_temp * direction_constant));
 543              		.loc 1 284 0 discriminator 3
 544 016e 9DED030A 		vldr.32	s0, [sp, #12]
 545 0172 DFED478A 		vldr.32	s17, .L66+48
 546 0176 20EE280A 		vmul.f32	s0, s0, s17
 547 017a FFF7FEFF 		bl	cosf
 548              	.LVL73:
 549 017e 9FED458A 		vldr.32	s16, .L66+52
 550 0182 20EE080A 		vmul.f32	s0, s0, s16
 551 0186 BDEEC00A 		vcvt.s32.f32	s0, s0
 552 018a 10EE103A 		vmov	r3, s0	@ int
 553 018e 1DB2     		sxth	r5, r3
 554              	.LVL74:
 285:../src/wx_handler.c **** 			wind_direction_y = (int16_t)(100.0f * sinf(dir_temp * direction_constant));
 555              		.loc 1 285 0 discriminator 3
 556 0190 9DED030A 		vldr.32	s0, [sp, #12]
 557 0194 20EE280A 		vmul.f32	s0, s0, s17
 558 0198 FFF7FEFF 		bl	sinf
 559              	.LVL75:
 560 019c 20EE080A 		vmul.f32	s0, s0, s16
 561 01a0 BDEEC00A 		vcvt.s32.f32	s0, s0
 562              	.LVL76:
 286:../src/wx_handler.c **** 
 287:../src/wx_handler.c **** 			// adding components to calculate average
 288:../src/wx_handler.c **** 			wind_direction_x_avg += wind_direction_x;
 563              		.loc 1 288 0 discriminator 3
 564 01a4 A844     		add	r8, r8, r5
 565              	.LVL77:
 289:../src/wx_handler.c **** 			wind_direction_y_avg += wind_direction_y;
 566              		.loc 1 289 0 discriminator 3
 567 01a6 10EE103A 		vmov	r3, s0	@ int
 568 01aa 07FA83F7 		sxtah	r7, r7, r3
 569              	.LVL78:
 279:../src/wx_handler.c **** 
 570              		.loc 1 279 0 discriminator 3
 571 01ae 0134     		adds	r4, r4, #1
 572              	.LVL79:
 573 01b0 24B2     		sxth	r4, r4
 574              	.LVL80:
 575              	.L43:
 279:../src/wx_handler.c **** 
 576              		.loc 1 279 0 is_stmt 0 discriminator 1
 577 01b2 A642     		cmp	r6, r4
 578 01b4 D2DC     		bgt	.L44
 290:../src/wx_handler.c **** 
 291:../src/wx_handler.c **** 		}
 292:../src/wx_handler.c **** 
 293:../src/wx_handler.c **** 		// dividing to get average of x and y componen
 294:../src/wx_handler.c **** 		wind_direction_x_avg /= average_ln;
 579              		.loc 1 294 0 is_stmt 1
 580 01b6 98FBF6F3 		sdiv	r3, r8, r6
 581 01ba 00EE903A 		vmov	s1, r3	@ int
 582              	.LVL81:
 295:../src/wx_handler.c **** 		wind_direction_y_avg /= average_ln;
 583              		.loc 1 295 0
 584 01be 97FBF6F3 		sdiv	r3, r7, r6
 585              	.LVL82:
 586 01c2 00EE103A 		vmov	s0, r3	@ int
 587              	.LVL83:
 296:../src/wx_handler.c **** 
 297:../src/wx_handler.c **** 		// converting x & y component of wind direction back to an angle
 298:../src/wx_handler.c **** 		arctan_value = atan2f(wind_direction_y_avg , wind_direction_x_avg);
 588              		.loc 1 298 0
 589 01c6 F8EEE00A 		vcvt.f32.s32	s1, s1
 590              	.LVL84:
 591 01ca B8EEC00A 		vcvt.f32.s32	s0, s0
 592 01ce FFF7FEFF 		bl	atan2f
 593              	.LVL85:
 594 01d2 8DED020A 		vstr.32	s0, [sp, #8]
 299:../src/wx_handler.c **** 
 300:../src/wx_handler.c **** 		rte_wx_average_winddirection = (int16_t)(arctan_value * (180.0f/M_PI));
 595              		.loc 1 300 0
 596 01d6 0298     		ldr	r0, [sp, #8]	@ float
 597 01d8 FFF7FEFF 		bl	__aeabi_f2d
 598              	.LVL86:
 599 01dc 20A3     		adr	r3, .L66
 600 01de D3E90023 		ldrd	r2, [r3]
 601 01e2 FFF7FEFF 		bl	__aeabi_dmul
 602              	.LVL87:
 603 01e6 FFF7FEFF 		bl	__aeabi_d2iz
 604              	.LVL88:
 605 01ea 234B     		ldr	r3, .L66+24
 606 01ec 1880     		strh	r0, [r3]	@ movhi
 607              	.LVL89:
 608              	.L34:
 301:../src/wx_handler.c **** 
 302:../src/wx_handler.c **** 		if (rte_wx_average_winddirection < 0)
 303:../src/wx_handler.c **** 			rte_wx_average_winddirection += 360;
 304:../src/wx_handler.c **** 
 305:../src/wx_handler.c **** 	}
 306:../src/wx_handler.c **** 
 307:../src/wx_handler.c **** 	if (config_sources->wind == WX_SOURCE_FULL_RTU || config_sources->wind != WX_SOURCE_RTU) {
 609              		.loc 1 307 0
 610 01ee 99F80330 		ldrb	r3, [r9, #3]	@ zero_extendqisi2
 611 01f2 032B     		cmp	r3, #3
 612 01f4 26D0     		beq	.L45
 308:../src/wx_handler.c **** 		if (modbus_retval == MODBUS_RET_OK) {
 613              		.loc 1 308 0
 614 01f6 BAF1000F 		cmp	r10, #0
 615 01fa 0ED0     		beq	.L61
 309:../src/wx_handler.c **** 			rte_wx_wind_qf = AN_WIND_QF_FULL;
 310:../src/wx_handler.c **** 		}
 311:../src/wx_handler.c **** 		else if (modbus_retval == MODBUS_RET_DEGRADED) {
 616              		.loc 1 311 0
 617 01fc BAF1060F 		cmp	r10, #6
 618 0200 13D0     		beq	.L62
 312:../src/wx_handler.c **** 			rte_wx_wind_qf = AN_WIND_QF_DEGRADED;
 313:../src/wx_handler.c **** 		}
 314:../src/wx_handler.c **** 		else if (modbus_retval == MODBUS_RET_NOT_AVALIABLE) {
 619              		.loc 1 314 0
 620 0202 BAF1050F 		cmp	r10, #5
 621 0206 14D0     		beq	.L63
 315:../src/wx_handler.c **** 			rte_wx_wind_qf = AN_WIND_QF_NOT_AVALIABLE;
 316:../src/wx_handler.c **** 		}
 317:../src/wx_handler.c **** 		else {
 318:../src/wx_handler.c **** 			if ((config_mode->wx & WX_INTERNAL_AS_BACKUP) != 0)
 622              		.loc 1 318 0
 623 0208 9BF80130 		ldrb	r3, [fp, #1]	@ zero_extendqisi2
 624 020c 13F0020F 		tst	r3, #2
 625 0210 13D1     		bne	.L64
 319:../src/wx_handler.c **** 				rte_wx_wind_qf = analog_anemometer_get_qf();
 320:../src/wx_handler.c **** 			else
 321:../src/wx_handler.c **** 				rte_wx_wind_qf = AN_WIND_QF_NOT_AVALIABLE;
 626              		.loc 1 321 0
 627 0212 214B     		ldr	r3, .L66+56
 628 0214 0422     		movs	r2, #4
 629 0216 1A70     		strb	r2, [r3]
 630 0218 02E0     		b	.L26
 631              	.L61:
 309:../src/wx_handler.c **** 		}
 632              		.loc 1 309 0
 633 021a 1F4B     		ldr	r3, .L66+56
 634 021c 0022     		movs	r2, #0
 635 021e 1A70     		strb	r2, [r3]
 636              	.L26:
 322:../src/wx_handler.c **** 		}
 323:../src/wx_handler.c **** 	}
 324:../src/wx_handler.c **** 	else if (config_sources->wind == WX_SOURCE_INTERNAL) {
 325:../src/wx_handler.c **** 		rte_wx_wind_qf = analog_anemometer_get_qf();
 326:../src/wx_handler.c **** 	}
 327:../src/wx_handler.c **** 	else {
 328:../src/wx_handler.c **** 		rte_wx_wind_qf = AN_WIND_QF_UNKNOWN;
 329:../src/wx_handler.c **** 	}
 330:../src/wx_handler.c **** 
 331:../src/wx_handler.c **** 
 332:../src/wx_handler.c **** }
 637              		.loc 1 332 0
 638 0220 05B0     		add	sp, sp, #20
 639              		.cfi_remember_state
 640              		.cfi_def_cfa_offset 44
 641              		@ sp needed
 642 0222 BDEC028B 		vldm	sp!, {d8}
 643              		.cfi_restore 80
 644              		.cfi_restore 81
 645              		.cfi_def_cfa_offset 36
 646 0226 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 647              	.LVL90:
 648              	.L62:
 649              		.cfi_restore_state
 312:../src/wx_handler.c **** 		}
 650              		.loc 1 312 0
 651 022a 1B4B     		ldr	r3, .L66+56
 652 022c 0322     		movs	r2, #3
 653 022e 1A70     		strb	r2, [r3]
 654 0230 F6E7     		b	.L26
 655              	.L63:
 315:../src/wx_handler.c **** 		}
 656              		.loc 1 315 0
 657 0232 194B     		ldr	r3, .L66+56
 658 0234 0422     		movs	r2, #4
 659 0236 1A70     		strb	r2, [r3]
 660 0238 F2E7     		b	.L26
 661              	.L64:
 319:../src/wx_handler.c **** 			else
 662              		.loc 1 319 0
 663 023a FFF7FEFF 		bl	analog_anemometer_get_qf
 664              	.LVL91:
 665 023e 164B     		ldr	r3, .L66+56
 666 0240 1870     		strb	r0, [r3]
 667 0242 EDE7     		b	.L26
 668              	.L45:
 324:../src/wx_handler.c **** 		rte_wx_wind_qf = analog_anemometer_get_qf();
 669              		.loc 1 324 0
 670 0244 012B     		cmp	r3, #1
 671 0246 03D0     		beq	.L65
 328:../src/wx_handler.c **** 	}
 672              		.loc 1 328 0
 673 0248 134B     		ldr	r3, .L66+56
 674 024a 0522     		movs	r2, #5
 675 024c 1A70     		strb	r2, [r3]
 676              		.loc 1 332 0
 677 024e E7E7     		b	.L26
 678              	.L65:
 325:../src/wx_handler.c **** 	}
 679              		.loc 1 325 0
 680 0250 FFF7FEFF 		bl	analog_anemometer_get_qf
 681              	.LVL92:
 682 0254 104B     		ldr	r3, .L66+56
 683 0256 1870     		strb	r0, [r3]
 684 0258 E2E7     		b	.L26
 685              	.L67:
 686 025a 00BFAFF3 		.align	3
 686      0080
 687              	.L66:
 688 0260 F8C1631A 		.word	442745336
 689 0264 DCA54C40 		.word	1078765020
 690 0268 00000000 		.word	.LANCHOR2
 691 026c 00000000 		.word	rte_wx_windspeed_it
 692 0270 00000000 		.word	rte_wx_windspeed
 693 0274 00000000 		.word	rte_wx_windspeed_pulses
 694 0278 00000000 		.word	rte_wx_average_winddirection
 695 027c 00000000 		.word	rte_wx_average_windspeed
 696 0280 00000000 		.word	rte_wx_max_windspeed
 697 0284 00000000 		.word	rte_wx_winddirection_last
 698 0288 00000000 		.word	rte_wx_winddirection_it
 699 028c 00000000 		.word	rte_wx_winddirection
 700 0290 35FA8E3C 		.word	1016003125
 701 0294 0000C842 		.word	1120403456
 702 0298 00000000 		.word	rte_wx_wind_qf
 703              		.cfi_endproc
 704              	.LFE406:
 706              		.section	.text.wx_pwr_init,"ax",%progbits
 707              		.align	1
 708              		.global	wx_pwr_init
 709              		.syntax unified
 710              		.thumb
 711              		.thumb_func
 712              		.fpu fpv4-sp-d16
 714              	wx_pwr_init:
 715              	.LFB407:
 333:../src/wx_handler.c **** 
 334:../src/wx_handler.c **** void wx_pwr_init(void) {
 716              		.loc 1 334 0
 717              		.cfi_startproc
 718              		@ args = 0, pretend = 0, frame = 24
 719              		@ frame_needed = 0, uses_anonymous_args = 0
 720 0000 00B5     		push	{lr}
 721              		.cfi_def_cfa_offset 4
 722              		.cfi_offset 14, -4
 723 0002 87B0     		sub	sp, sp, #28
 724              		.cfi_def_cfa_offset 32
 335:../src/wx_handler.c **** #if defined(PARATNC_HWREV_A) || defined(PARATNC_HWREV_B) || defined(PARATNC_HWREV_C)
 336:../src/wx_handler.c **** 
 337:../src/wx_handler.c **** 			// RELAY_CNTRL
 338:../src/wx_handler.c **** 			GPIO_InitTypeDef GPIO_InitStructure;
 339:../src/wx_handler.c **** 			GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;
 340:../src/wx_handler.c **** 			GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 341:../src/wx_handler.c **** 		#if (defined PARATNC_HWREV_A || defined PARATNC_HWREV_B)
 342:../src/wx_handler.c **** 			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;
 343:../src/wx_handler.c **** 		#elif (defined PARATNC_HWREV_C)
 344:../src/wx_handler.c **** 			GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
 345:../src/wx_handler.c **** 		#else
 346:../src/wx_handler.c **** 		#error ("Hardware Revision not chosen.")
 347:../src/wx_handler.c **** 		#endif
 348:../src/wx_handler.c **** 			GPIO_Init(GPIOB, &GPIO_InitStructure);
 349:../src/wx_handler.c **** 
 350:../src/wx_handler.c **** 		#if (defined PARATNC_HWREV_C)
 351:../src/wx_handler.c **** 			// +12V PWR_CNTRL
 352:../src/wx_handler.c **** 			GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
 353:../src/wx_handler.c **** 			GPIO_Init(GPIOA, &GPIO_InitStructure);
 354:../src/wx_handler.c **** 		#endif
 355:../src/wx_handler.c **** 
 356:../src/wx_handler.c **** 			wx_pwr_state = WX_PWR_OFF;
 357:../src/wx_handler.c **** 
 358:../src/wx_handler.c **** 			GPIO_ResetBits(GPIOB, GPIO_Pin_8);
 359:../src/wx_handler.c **** 
 360:../src/wx_handler.c **** 		#if (defined PARATNC_HWREV_C)
 361:../src/wx_handler.c **** 			// +12V_SW PWR_CNTRL
 362:../src/wx_handler.c **** 			GPIO_ResetBits(GPIOA, GPIO_Pin_6);
 363:../src/wx_handler.c **** 		#endif
 364:../src/wx_handler.c **** 
 365:../src/wx_handler.c **** #endif
 366:../src/wx_handler.c **** 
 367:../src/wx_handler.c **** #if defined(PARAMETEO)
 368:../src/wx_handler.c **** 			LL_GPIO_InitTypeDef GPIO_InitTypeDef;
 369:../src/wx_handler.c **** 
 370:../src/wx_handler.c **** 			GPIO_InitTypeDef.Mode = LL_GPIO_MODE_OUTPUT;
 725              		.loc 1 370 0
 726 0004 0123     		movs	r3, #1
 727 0006 0193     		str	r3, [sp, #4]
 371:../src/wx_handler.c **** 			GPIO_InitTypeDef.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 728              		.loc 1 371 0
 729 0008 0022     		movs	r2, #0
 730 000a 0392     		str	r2, [sp, #12]
 372:../src/wx_handler.c **** 			GPIO_InitTypeDef.Pin = LL_GPIO_PIN_8;
 731              		.loc 1 372 0
 732 000c 4FF48071 		mov	r1, #256
 733 0010 0091     		str	r1, [sp]
 373:../src/wx_handler.c **** 			GPIO_InitTypeDef.Pull = LL_GPIO_PULL_NO;
 734              		.loc 1 373 0
 735 0012 0492     		str	r2, [sp, #16]
 374:../src/wx_handler.c **** 			GPIO_InitTypeDef.Speed = LL_GPIO_SPEED_FREQ_MEDIUM;
 736              		.loc 1 374 0
 737 0014 0293     		str	r3, [sp, #8]
 375:../src/wx_handler.c **** 			GPIO_InitTypeDef.Alternate = LL_GPIO_AF_7;
 738              		.loc 1 375 0
 739 0016 0723     		movs	r3, #7
 740 0018 0593     		str	r3, [sp, #20]
 376:../src/wx_handler.c **** 			LL_GPIO_Init(GPIOB, &GPIO_InitTypeDef);
 741              		.loc 1 376 0
 742 001a 6946     		mov	r1, sp
 743 001c 0248     		ldr	r0, .L70
 744 001e FFF7FEFF 		bl	LL_GPIO_Init
 745              	.LVL93:
 377:../src/wx_handler.c **** 
 378:../src/wx_handler.c **** #endif
 379:../src/wx_handler.c **** }
 746              		.loc 1 379 0
 747 0022 07B0     		add	sp, sp, #28
 748              		.cfi_def_cfa_offset 4
 749              		@ sp needed
 750 0024 5DF804FB 		ldr	pc, [sp], #4
 751              	.L71:
 752              		.align	2
 753              	.L70:
 754 0028 00040048 		.word	1207960576
 755              		.cfi_endproc
 756              	.LFE407:
 758              		.section	.text.wx_pwr_periodic_handle,"ax",%progbits
 759              		.align	1
 760              		.global	wx_pwr_periodic_handle
 761              		.syntax unified
 762              		.thumb
 763              		.thumb_func
 764              		.fpu fpv4-sp-d16
 766              	wx_pwr_periodic_handle:
 767              	.LFB408:
 380:../src/wx_handler.c **** 
 381:../src/wx_handler.c **** void wx_pwr_periodic_handle(void) {
 768              		.loc 1 381 0
 769              		.cfi_startproc
 770              		@ args = 0, pretend = 0, frame = 0
 771              		@ frame_needed = 0, uses_anonymous_args = 0
 772 0000 08B5     		push	{r3, lr}
 773              		.cfi_def_cfa_offset 8
 774              		.cfi_offset 3, -8
 775              		.cfi_offset 14, -4
 382:../src/wx_handler.c **** 
 383:../src/wx_handler.c **** 	// do a last valid measuremenets timestamps only if power is currently applied
 384:../src/wx_handler.c **** 	if (wx_pwr_state == WX_PWR_ON) {
 776              		.loc 1 384 0
 777 0002 324B     		ldr	r3, .L81
 778 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 779 0006 012B     		cmp	r3, #1
 780 0008 06D0     		beq	.L80
 781              	.L73:
 385:../src/wx_handler.c **** 
 386:../src/wx_handler.c **** 		// the value of 0xFFFFFFFF is a magic word which disables the check for this parameter
 387:../src/wx_handler.c **** 		if (wx_last_good_temperature_time != 0xFFFFFFFF &&
 388:../src/wx_handler.c **** 			master_time - wx_last_good_temperature_time >= WX_WATCHDOG_PERIOD)
 389:../src/wx_handler.c **** 		{
 390:../src/wx_handler.c **** 			wx_pwr_state = WX_PWR_UNDER_RESET;
 391:../src/wx_handler.c **** 		}
 392:../src/wx_handler.c **** 
 393:../src/wx_handler.c **** 		// as the weather station could be configured not to perform wind measurements at all
 394:../src/wx_handler.c **** 		if (wx_last_good_wind_time != 0xFFFFFFFF &&
 395:../src/wx_handler.c **** 			master_time - wx_last_good_wind_time >= WX_WATCHDOG_PERIOD)
 396:../src/wx_handler.c **** 		{
 397:../src/wx_handler.c **** 			wx_pwr_state = WX_PWR_UNDER_RESET;
 398:../src/wx_handler.c **** 
 399:../src/wx_handler.c **** 			rte_wx_wind_qf = AN_WIND_QF_DEGRADED;
 400:../src/wx_handler.c **** 		}
 401:../src/wx_handler.c **** 
 402:../src/wx_handler.c **** 		if (wx_pwr_state == WX_PWR_UNDER_RESET) {
 403:../src/wx_handler.c **** 			// if timeout watchod expired there is a time to reset the supply voltage
 404:../src/wx_handler.c **** 			wx_pwr_state = WX_PWR_UNDER_RESET;
 405:../src/wx_handler.c **** 
 406:../src/wx_handler.c **** 			// pull the output down to switch the relay and disable +5V_ISOL (VDD_SW)
 407:../src/wx_handler.c **** 			//GPIO_ResetBits(GPIOB, GPIO_Pin_8);
 408:../src/wx_handler.c **** 			io_5v_isol_sw_cntrl_vbat_s_disable();
 409:../src/wx_handler.c **** 
 410:../src/wx_handler.c **** #ifdef PWR_SWITCH_BOTH
 411:../src/wx_handler.c **** 			io_12v_sw_cntrl_vbat_g_disable();
 412:../src/wx_handler.c **** 			//GPIO_ResetBits(GPIOA, GPIO_Pin_6);
 413:../src/wx_handler.c **** #endif
 414:../src/wx_handler.c **** 
 415:../src/wx_handler.c **** 			// setting the last_good timers to current value to prevent reset loop
 416:../src/wx_handler.c **** 			wx_last_good_temperature_time = master_time;
 417:../src/wx_handler.c **** 			wx_last_good_wind_time = master_time;
 418:../src/wx_handler.c **** 
 419:../src/wx_handler.c **** 			return;
 420:../src/wx_handler.c **** 		}
 421:../src/wx_handler.c **** 
 422:../src/wx_handler.c **** 	}
 423:../src/wx_handler.c **** 
 424:../src/wx_handler.c **** 	// service actual supply state
 425:../src/wx_handler.c **** 	switch (wx_pwr_state) {
 782              		.loc 1 425 0
 783 000a 304B     		ldr	r3, .L81
 784 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 785 000e 002B     		cmp	r3, #0
 786 0010 3AD0     		beq	.L77
 787 0012 022B     		cmp	r3, #2
 788 0014 48D0     		beq	.L78
 789              	.L72:
 426:../src/wx_handler.c **** 	case WX_PWR_OFF:
 427:../src/wx_handler.c **** 
 428:../src/wx_handler.c **** 		// one second delay
 429:../src/wx_handler.c **** 		delay_fixed(2000);
 430:../src/wx_handler.c **** 
 431:../src/wx_handler.c **** #if (defined PARATNC_HWREV_C)
 432:../src/wx_handler.c **** 		// Turn on the +12V_SW voltage
 433:../src/wx_handler.c **** 		GPIO_SetBits(GPIOA, GPIO_Pin_6);
 434:../src/wx_handler.c **** #endif
 435:../src/wx_handler.c **** 
 436:../src/wx_handler.c **** 		delay_fixed(100);
 437:../src/wx_handler.c **** 
 438:../src/wx_handler.c **** 		// Turn on the +5V_ISOL (VDD_SW) voltage
 439:../src/wx_handler.c **** 		//GPIO_SetBits(GPIOB, GPIO_Pin_8);
 440:../src/wx_handler.c **** 		io_5v_isol_sw_cntrl_vbat_s_enable();
 441:../src/wx_handler.c **** 
 442:../src/wx_handler.c **** 		// power is off after power-up and needs to be powered on
 443:../src/wx_handler.c **** 		wx_pwr_state = WX_PWR_ON;
 444:../src/wx_handler.c **** 		break;
 445:../src/wx_handler.c **** 	case WX_PWR_ON:
 446:../src/wx_handler.c **** 		break;
 447:../src/wx_handler.c **** 	case WX_PWR_UNDER_RESET:
 448:../src/wx_handler.c **** 
 449:../src/wx_handler.c **** 		// Turn on the +5V_ISOL (VDD_SW) voltage
 450:../src/wx_handler.c **** 		//GPIO_SetBits(GPIOB, GPIO_Pin_8);
 451:../src/wx_handler.c **** 		io_5v_isol_sw_cntrl_vbat_s_enable();
 452:../src/wx_handler.c **** 
 453:../src/wx_handler.c **** #ifdef PWR_SWITCH_BOTH
 454:../src/wx_handler.c **** 		//GPIO_SetBits(GPIOA, GPIO_Pin_6);
 455:../src/wx_handler.c **** 		io_12v_sw_cntrl_vbat_g_enable();
 456:../src/wx_handler.c **** 
 457:../src/wx_handler.c **** 		wx_force_i2c_sensor_reset = 1;
 458:../src/wx_handler.c **** #endif
 459:../src/wx_handler.c **** 
 460:../src/wx_handler.c **** 		wx_pwr_state = WX_PWR_ON;
 461:../src/wx_handler.c **** 
 462:../src/wx_handler.c **** 		break;
 463:../src/wx_handler.c **** 	case WX_PWR_DISABLED:
 464:../src/wx_handler.c **** 		break;
 465:../src/wx_handler.c **** 	}
 466:../src/wx_handler.c **** }
 790              		.loc 1 466 0
 791 0016 08BD     		pop	{r3, pc}
 792              	.L80:
 387:../src/wx_handler.c **** 			master_time - wx_last_good_temperature_time >= WX_WATCHDOG_PERIOD)
 793              		.loc 1 387 0
 794 0018 2D4B     		ldr	r3, .L81+4
 795 001a 1B68     		ldr	r3, [r3]
 796 001c B3F1FF3F 		cmp	r3, #-1
 797 0020 08D0     		beq	.L74
 388:../src/wx_handler.c **** 		{
 798              		.loc 1 388 0 discriminator 1
 799 0022 2C4A     		ldr	r2, .L81+8
 800 0024 1268     		ldr	r2, [r2]
 801 0026 D31A     		subs	r3, r2, r3
 387:../src/wx_handler.c **** 			master_time - wx_last_good_temperature_time >= WX_WATCHDOG_PERIOD)
 802              		.loc 1 387 0 discriminator 1
 803 0028 2B4A     		ldr	r2, .L81+12
 804 002a 9342     		cmp	r3, r2
 805 002c 02D9     		bls	.L74
 390:../src/wx_handler.c **** 		}
 806              		.loc 1 390 0
 807 002e 274B     		ldr	r3, .L81
 808 0030 0222     		movs	r2, #2
 809 0032 1A70     		strb	r2, [r3]
 810              	.L74:
 394:../src/wx_handler.c **** 			master_time - wx_last_good_wind_time >= WX_WATCHDOG_PERIOD)
 811              		.loc 1 394 0
 812 0034 294B     		ldr	r3, .L81+16
 813 0036 1B68     		ldr	r3, [r3]
 814 0038 B3F1FF3F 		cmp	r3, #-1
 815 003c 0BD0     		beq	.L75
 395:../src/wx_handler.c **** 		{
 816              		.loc 1 395 0 discriminator 1
 817 003e 254A     		ldr	r2, .L81+8
 818 0040 1268     		ldr	r2, [r2]
 819 0042 D31A     		subs	r3, r2, r3
 394:../src/wx_handler.c **** 			master_time - wx_last_good_wind_time >= WX_WATCHDOG_PERIOD)
 820              		.loc 1 394 0 discriminator 1
 821 0044 244A     		ldr	r2, .L81+12
 822 0046 9342     		cmp	r3, r2
 823 0048 05D9     		bls	.L75
 397:../src/wx_handler.c **** 
 824              		.loc 1 397 0
 825 004a 204B     		ldr	r3, .L81
 826 004c 0222     		movs	r2, #2
 827 004e 1A70     		strb	r2, [r3]
 399:../src/wx_handler.c **** 		}
 828              		.loc 1 399 0
 829 0050 234B     		ldr	r3, .L81+20
 830 0052 0322     		movs	r2, #3
 831 0054 1A70     		strb	r2, [r3]
 832              	.L75:
 402:../src/wx_handler.c **** 			// if timeout watchod expired there is a time to reset the supply voltage
 833              		.loc 1 402 0
 834 0056 1D4B     		ldr	r3, .L81
 835 0058 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 836 005a 022B     		cmp	r3, #2
 837 005c D5D1     		bne	.L73
 404:../src/wx_handler.c **** 
 838              		.loc 1 404 0
 839 005e 1B4B     		ldr	r3, .L81
 840 0060 0222     		movs	r2, #2
 841 0062 1A70     		strb	r2, [r3]
 842              	.LBB12:
 843              	.LBB13:
 844              		.file 2 "../src/io.h"
   1:../src/io.h   **** /*
   2:../src/io.h   ****  * io.h
   3:../src/io.h   ****  *
   4:../src/io.h   ****  *  Created on: 11.06.2020
   5:../src/io.h   ****  *      Author: mateusz
   6:../src/io.h   ****  */
   7:../src/io.h   **** 
   8:../src/io.h   **** #ifndef IO_H_
   9:../src/io.h   **** #define IO_H_
  10:../src/io.h   **** 
  11:../src/io.h   **** #ifdef STM32F10X_MD_VL
  12:../src/io.h   **** #include <stm32f10x.h>
  13:../src/io.h   **** #endif
  14:../src/io.h   **** #ifdef STM32L471xx
  15:../src/io.h   **** #include <stm32l4xx.h>
  16:../src/io.h   **** #endif
  17:../src/io.h   **** 
  18:../src/io.h   **** void io_oc_init(void);
  19:../src/io.h   **** void io_oc_output_low(void);
  20:../src/io.h   **** void io_oc_output_hiz(void);
  21:../src/io.h   **** 
  22:../src/io.h   **** void io_ext_watchdog_config(void);
  23:../src/io.h   **** void io_ext_watchdog_service(void);
  24:../src/io.h   **** 
  25:../src/io.h   **** //void io_5v_isol_sw_cntrl_vbat_s_enable(void);
  26:../src/io.h   **** //void io_5v_isol_sw_cntrl_vbat_s_disable(void);
  27:../src/io.h   **** //
  28:../src/io.h   **** //void io_12v_sw_cntrl_vbat_g_enable(void);
  29:../src/io.h   **** //void io_12v_sw_cntrl_vbat_g_disable(void);
  30:../src/io.h   **** 
  31:../src/io.h   **** inline void io_5v_isol_sw_cntrl_vbat_s_enable(void) {
  32:../src/io.h   **** 	GPIOB->BSRR |= GPIO_BSRR_BS8;
  33:../src/io.h   **** }
  34:../src/io.h   **** inline void io_5v_isol_sw_cntrl_vbat_s_disable(void) {
  35:../src/io.h   **** 	GPIOB->BSRR |= GPIO_BSRR_BR8;
 845              		.loc 2 35 0
 846 0064 1F4A     		ldr	r2, .L81+24
 847 0066 9369     		ldr	r3, [r2, #24]
 848 0068 43F08073 		orr	r3, r3, #16777216
 849 006c 9361     		str	r3, [r2, #24]
 850              	.LBE13:
 851              	.LBE12:
 852              	.LBB14:
 853              	.LBB15:
  36:../src/io.h   **** }
  37:../src/io.h   **** 
  38:../src/io.h   **** inline void io_12v_sw_cntrl_vbat_g_enable(void) {
  39:../src/io.h   **** 	GPIOA->BSRR |= GPIO_BSRR_BS6;
  40:../src/io.h   **** 
  41:../src/io.h   **** }
  42:../src/io.h   **** inline void io_12v_sw_cntrl_vbat_g_disable(void) {
  43:../src/io.h   **** 	GPIOA->BSRR |= GPIO_BSRR_BR6;
 854              		.loc 2 43 0
 855 006e 4FF09042 		mov	r2, #1207959552
 856 0072 9369     		ldr	r3, [r2, #24]
 857 0074 43F48003 		orr	r3, r3, #4194304
 858 0078 9361     		str	r3, [r2, #24]
 859              	.LBE15:
 860              	.LBE14:
 416:../src/wx_handler.c **** 			wx_last_good_wind_time = master_time;
 861              		.loc 1 416 0
 862 007a 164B     		ldr	r3, .L81+8
 863 007c 1B68     		ldr	r3, [r3]
 864 007e 144A     		ldr	r2, .L81+4
 865 0080 1360     		str	r3, [r2]
 417:../src/wx_handler.c **** 
 866              		.loc 1 417 0
 867 0082 164A     		ldr	r2, .L81+16
 868 0084 1360     		str	r3, [r2]
 419:../src/wx_handler.c **** 		}
 869              		.loc 1 419 0
 870 0086 C6E7     		b	.L72
 871              	.L77:
 429:../src/wx_handler.c **** 
 872              		.loc 1 429 0
 873 0088 4FF4FA60 		mov	r0, #2000
 874 008c FFF7FEFF 		bl	delay_fixed
 875              	.LVL94:
 436:../src/wx_handler.c **** 
 876              		.loc 1 436 0
 877 0090 6420     		movs	r0, #100
 878 0092 FFF7FEFF 		bl	delay_fixed
 879              	.LVL95:
 880              	.LBB16:
 881              	.LBB17:
  32:../src/io.h   **** }
 882              		.loc 2 32 0
 883 0096 134A     		ldr	r2, .L81+24
 884 0098 9369     		ldr	r3, [r2, #24]
 885 009a 43F48073 		orr	r3, r3, #256
 886 009e 9361     		str	r3, [r2, #24]
 887              	.LBE17:
 888              	.LBE16:
 443:../src/wx_handler.c **** 		break;
 889              		.loc 1 443 0
 890 00a0 0A4B     		ldr	r3, .L81
 891 00a2 0122     		movs	r2, #1
 892 00a4 1A70     		strb	r2, [r3]
 444:../src/wx_handler.c **** 	case WX_PWR_ON:
 893              		.loc 1 444 0
 894 00a6 B6E7     		b	.L72
 895              	.L78:
 896              	.LBB18:
 897              	.LBB19:
  32:../src/io.h   **** }
 898              		.loc 2 32 0
 899 00a8 0E4A     		ldr	r2, .L81+24
 900 00aa 9369     		ldr	r3, [r2, #24]
 901 00ac 43F48073 		orr	r3, r3, #256
 902 00b0 9361     		str	r3, [r2, #24]
 903              	.LBE19:
 904              	.LBE18:
 905              	.LBB20:
 906              	.LBB21:
  39:../src/io.h   **** 
 907              		.loc 2 39 0
 908 00b2 4FF09042 		mov	r2, #1207959552
 909 00b6 9369     		ldr	r3, [r2, #24]
 910 00b8 43F04003 		orr	r3, r3, #64
 911 00bc 9361     		str	r3, [r2, #24]
 912              	.LBE21:
 913              	.LBE20:
 457:../src/wx_handler.c **** #endif
 914              		.loc 1 457 0
 915 00be 0123     		movs	r3, #1
 916 00c0 094A     		ldr	r2, .L81+28
 917 00c2 1370     		strb	r3, [r2]
 460:../src/wx_handler.c **** 
 918              		.loc 1 460 0
 919 00c4 014A     		ldr	r2, .L81
 920 00c6 1370     		strb	r3, [r2]
 462:../src/wx_handler.c **** 	case WX_PWR_DISABLED:
 921              		.loc 1 462 0
 922 00c8 A5E7     		b	.L72
 923              	.L82:
 924 00ca 00BF     		.align	2
 925              	.L81:
 926 00cc 00000000 		.word	wx_pwr_state
 927 00d0 00000000 		.word	.LANCHOR3
 928 00d4 00000000 		.word	master_time
 929 00d8 8F5F0100 		.word	89999
 930 00dc 00000000 		.word	.LANCHOR4
 931 00e0 00000000 		.word	rte_wx_wind_qf
 932 00e4 00040048 		.word	1207960576
 933 00e8 00000000 		.word	.LANCHOR0
 934              		.cfi_endproc
 935              	.LFE408:
 937              		.global	wx_force_i2c_sensor_reset
 938              		.global	wx_wind_pool_call_counter
 939              		.comm	wx_pwr_state,1,1
 940              		.global	wx_last_good_temperature_time
 941              		.global	wx_last_good_wind_time
 942              		.section	.bss.wx_force_i2c_sensor_reset,"aw",%nobits
 943              		.set	.LANCHOR0,. + 0
 946              	wx_force_i2c_sensor_reset:
 947 0000 00       		.space	1
 948              		.section	.bss.wx_last_good_temperature_time,"aw",%nobits
 949              		.align	2
 950              		.set	.LANCHOR3,. + 0
 953              	wx_last_good_temperature_time:
 954 0000 00000000 		.space	4
 955              		.section	.bss.wx_last_good_wind_time,"aw",%nobits
 956              		.align	2
 957              		.set	.LANCHOR4,. + 0
 960              	wx_last_good_wind_time:
 961 0000 00000000 		.space	4
 962              		.section	.bss.wx_wind_pool_call_counter,"aw",%nobits
 963              		.align	2
 964              		.set	.LANCHOR2,. + 0
 967              	wx_wind_pool_call_counter:
 968 0000 00000000 		.space	4
 969              		.section	.rodata.internal,"a",%progbits
 970              		.align	2
 971              		.set	.LANCHOR1,. + 0
 974              	internal:
 975 0000 01       		.byte	1
 976 0001 01       		.byte	1
 977 0002 01       		.byte	1
 978 0003 01       		.byte	1
 979              		.text
 980              	.Letext0:
 981              		.file 3 "/usr/local/bin/gcc-arm-none-eabi-7-2018-q2-update/lib/gcc/arm-none-eabi/7.3.1/include/std
 982              		.file 4 "../include/config_data.h"
 983              		.file 5 "../include/wx_handler.h"
 984              		.file 6 "../system/include/cmsis/stm32l4xx/core_cm4.h"
 985              		.file 7 "../system/include/cmsis/stm32l4xx/device/system_stm32l4xx.h"
 986              		.file 8 "../system/include/cmsis/stm32l4xx/device/stm32l471xx.h"
 987              		.file 9 "../system/include/stm32l4-hal-driver/stm32l4xx_ll_gpio.h"
 988              		.file 10 "../system/include/drivers/dallas.h"
 989              		.file 11 "../system/include/drivers/analog_anemometer.h"
 990              		.file 12 "../system/include/davis_vantage/davis_loop_t.h"
 991              		.file 13 "../system/include/umb_master/umb_frame_t.h"
 992              		.file 14 "../system/include/umb_master/umb_state_t.h"
 993              		.file 15 "../system/include/drivers/serial.h"
 994              		.file 16 "../system/include/umb_master/umb_context_t.h"
 995              		.file 17 "../system/include/umb_master/umb_qf_t.h"
 996              		.file 18 "/usr/local/bin/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/lock.h"
 997              		.file 19 "/usr/local/bin/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/_types.h"
 998              		.file 20 "/usr/local/bin/gcc-arm-none-eabi-7-2018-q2-update/lib/gcc/arm-none-eabi/7.3.1/include/st
 999              		.file 21 "/usr/local/bin/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/sys/reent.h"
 1000              		.file 22 "/usr/local/bin/gcc-arm-none-eabi-7-2018-q2-update/arm-none-eabi/include/math.h"
 1001              		.file 23 "../system/include/drivers/ms5611.h"
 1002              		.file 24 "../system/include/drivers/bme280.h"
 1003              		.file 25 "../include/rte_wx.h"
 1004              		.file 26 "../system/include/modbus_rtu/rtu_register_data_t.h"
 1005              		.file 27 "../system/include/modbus_rtu/rtu_exception_t.h"
 1006              		.file 28 "../system/include/modbus_rtu/rtu_pool_queue_t.h"
 1007              		.file 29 "../include/rte_rtu.h"
 1008              		.file 30 "../include/rte_main.h"
 1009              		.file 31 "../system/include/aprs/cfifo.h"
 1010              		.file 32 "../system/include/aprs/afsk.h"
 1011              		.file 33 "../system/include/aprs/ax25.h"
 1012              		.file 34 "../include/main.h"
 1013              		.file 35 "../include/delay.h"
 1014              		.file 36 "../system/include/umb_master/umb_master.h"
 1015              		.file 37 "../system/include/modbus_rtu/rtu_getters.h"
 1016              		.file 38 "../include/wx_handler_temperature.h"
 1017              		.file 39 "../include/wx_handler_pressure.h"
 1018              		.file 40 "../include/wx_handler_humidity.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 wx_handler.c
     /tmp/cc4xjZWR.s:18     .text.wx_check_force_i2c_reset:0000000000000000 $t
     /tmp/cc4xjZWR.s:25     .text.wx_check_force_i2c_reset:0000000000000000 wx_check_force_i2c_reset
     /tmp/cc4xjZWR.s:62     .text.wx_check_force_i2c_reset:0000000000000024 $d
     /tmp/cc4xjZWR.s:68     .text.wx_get_all_measurements:0000000000000000 $t
     /tmp/cc4xjZWR.s:75     .text.wx_get_all_measurements:0000000000000000 wx_get_all_measurements
     /tmp/cc4xjZWR.s:178    .text.wx_get_all_measurements:0000000000000084 $d
     /tmp/cc4xjZWR.s:183    .text.wx_get_bme280_temperature_pressure_humidity:0000000000000000 $t
     /tmp/cc4xjZWR.s:190    .text.wx_get_bme280_temperature_pressure_humidity:0000000000000000 wx_get_bme280_temperature_pressure_humidity
     /tmp/cc4xjZWR.s:229    .text.wx_get_bme280_temperature_pressure_humidity:0000000000000020 $d
     /tmp/cc4xjZWR.s:238    .text.wx_pool_anemometer:0000000000000000 $t
     /tmp/cc4xjZWR.s:245    .text.wx_pool_anemometer:0000000000000000 wx_pool_anemometer
     /tmp/cc4xjZWR.s:688    .text.wx_pool_anemometer:0000000000000260 $d
     /tmp/cc4xjZWR.s:707    .text.wx_pwr_init:0000000000000000 $t
     /tmp/cc4xjZWR.s:714    .text.wx_pwr_init:0000000000000000 wx_pwr_init
     /tmp/cc4xjZWR.s:754    .text.wx_pwr_init:0000000000000028 $d
     /tmp/cc4xjZWR.s:759    .text.wx_pwr_periodic_handle:0000000000000000 $t
     /tmp/cc4xjZWR.s:766    .text.wx_pwr_periodic_handle:0000000000000000 wx_pwr_periodic_handle
     /tmp/cc4xjZWR.s:926    .text.wx_pwr_periodic_handle:00000000000000cc $d
                            *COM*:0000000000000001 wx_pwr_state
     /tmp/cc4xjZWR.s:946    .bss.wx_force_i2c_sensor_reset:0000000000000000 wx_force_i2c_sensor_reset
     /tmp/cc4xjZWR.s:967    .bss.wx_wind_pool_call_counter:0000000000000000 wx_wind_pool_call_counter
     /tmp/cc4xjZWR.s:953    .bss.wx_last_good_temperature_time:0000000000000000 wx_last_good_temperature_time
     /tmp/cc4xjZWR.s:960    .bss.wx_last_good_wind_time:0000000000000000 wx_last_good_wind_time
     /tmp/cc4xjZWR.s:947    .bss.wx_force_i2c_sensor_reset:0000000000000000 $d
     /tmp/cc4xjZWR.s:949    .bss.wx_last_good_temperature_time:0000000000000000 $d
     /tmp/cc4xjZWR.s:956    .bss.wx_last_good_wind_time:0000000000000000 $d
     /tmp/cc4xjZWR.s:963    .bss.wx_wind_pool_call_counter:0000000000000000 $d
     /tmp/cc4xjZWR.s:970    .rodata.internal:0000000000000000 $d
     /tmp/cc4xjZWR.s:974    .rodata.internal:0000000000000000 internal
                           .group:0000000000000000 wm4.0.95bc707da9dcffdc6c8c58936cbc8421
                           .group:0000000000000000 wm4.stdintgcc.h.29.6d480f4ba0f60596e88234283d42444f
                           .group:0000000000000000 wm4.config_data.h.9.6026a38cd2f39158a8fd50707ba1bf90
                           .group:0000000000000000 wm4.wx_handler.h.17.fa2077dbbd4afb2d90289f874af54dc5
                           .group:0000000000000000 wm4.station_config.h.9.d547169434a316afe56104ac612d2109
                           .group:0000000000000000 wm4.station_config_target_hw.h.9.a20e080416e80d1cff9c1b51cc464832
                           .group:0000000000000000 wm4.stm32l4xx.h.39.54a1fe1e096c7852edd649652f013a11
                           .group:0000000000000000 wm4.stm32l471xx.h.35.e78ad65c513105dda311dc495ac74d04
                           .group:0000000000000000 wm4.cmsis_version.h.32.46e8eccfa2cfeaae11d008bb2823a3ed
                           .group:0000000000000000 wm4.core_cm4.h.66.e4ff136c4a17abc46741866f64f8e729
                           .group:0000000000000000 wm4.cmsis_gcc.h.26.b6144e50d34fc998dd4c2cfb6387cf91
                           .group:0000000000000000 wm4.core_cm4.h.174.fcddd62df80231752fa39eb9b61dadfe
                           .group:0000000000000000 wm4.mpu_armv7.h.32.4049752bb5792d4e15357775e9506cfc
                           .group:0000000000000000 wm4.stm32l471xx.h.423.ceac761476affad641a3347d7727acfd
                           .group:0000000000000000 wm4.stm32l4xx.h.197.fb1c68184133668ca24c44c29ba4361f
                           .group:0000000000000000 wm4.stm32l4xx_ll_gpio.h.22.6ea69d1eee1200f6e0d48e871aaa811d
                           .group:0000000000000000 wm4.dallas.h.28.4c25313e4181236c94847de9c84bd06e
                           .group:0000000000000000 wm4.analog_anemometer.h.9.8c21570f6fc3dcd7763ba4d0d5168e3c
                           .group:0000000000000000 wm4.umb_frame_t.h.9.05796095a57acd1575f07118cb6ab058
                           .group:0000000000000000 wm4.umb_defines.h.9.77e79b84cd2dd9a74204aaeb1ca9d6be
                           .group:0000000000000000 wm4.stm32l4xx_ll_usart.h.22.ec2beebcd146668c5b35749264d7b58a
                           .group:0000000000000000 wm4.serial.h.14.eed7cf013c382ed4598746b40f0e2523
                           .group:0000000000000000 wm4._newlib_version.h.4.875b979a44719054cd750d0952ad3fd6
                           .group:0000000000000000 wm4.newlib.h.18.5e5ca3429233af402d406a202f1fc1ac
                           .group:0000000000000000 wm4.ieeefp.h.77.220d9cccac42cd58761758bee2df4ce6
                           .group:0000000000000000 wm4.features.h.22.fad1cec3bc7ff06488171438dbdcfd02
                           .group:0000000000000000 wm4.config.h.220.6cac6a9685cfce5e83c17784171638d9
                           .group:0000000000000000 wm4._ansi.h.31.de524f58584151836e90d8620a16f8e8
                           .group:0000000000000000 wm4.stddef.h.39.a38874c8f8a57e66301090908ec2a69f
                           .group:0000000000000000 wm4._default_types.h.6.959254cf5f09734ea7516c89e8bb21bd
                           .group:0000000000000000 wm4.lock.h.2.1461d1fff82dffe8bfddc23307f6484f
                           .group:0000000000000000 wm4._types.h.125.5cf8a495f1f7ef36777ad868a1e32068
                           .group:0000000000000000 wm4.stddef.h.161.5349cb105733e8777bfb0cf53c4e3f34
                           .group:0000000000000000 wm4._types.h.184.03611d4f6b5bec9997bcf4279eceba07
                           .group:0000000000000000 wm4.reent.h.17.90c2574d4acdcfce933db5cb09ff35fe
                           .group:0000000000000000 wm4.cdefs.h.47.7eec48e1bc15e3b0aff1089c232f5a9c
                           .group:0000000000000000 wm4.math.h.13.adb102f7bd7860b1f241e149d6914a1e
                           .group:0000000000000000 wm4.ms5611.h.13.84fbf6afa85557f675e3d85f1be6067c
                           .group:0000000000000000 wm4.bme280.h.9.aefe05f9329372f30337537cea488dce
                           .group:0000000000000000 wm4.rte_wx.h.30.cb80bd87f9fae81b43459954f1781e96
                           .group:0000000000000000 wm4.rtu_configuration.h.9.225559723a46d58da796e0ac6cb0b2ac
                           .group:0000000000000000 wm4.rtu_return_values.h.9.ebf5128ee53fb26e4da5d61aff7556b7
                           .group:0000000000000000 wm4.stdbool.h.29.07dce69c3b78884144b7f7bd19483461
                           .group:0000000000000000 wm4.macros.h.2.7a7a5ac48d4160b7481c806e80b68442
                           .group:0000000000000000 wm4.config.h.2.f5e96167cb26b0ce97c5e7513a95bc8b
                           .group:0000000000000000 wm4.afsk.h.17.cf8f922069680e152e1eddb76cd4cc82
                           .group:0000000000000000 wm4.ax25.h.18.077e42a4af9016476e34900472a8fe18
                           .group:0000000000000000 wm4.main.h.8.3d6ad69e5f061008d8c5cc5f5c9dd15a
                           .group:0000000000000000 wm4.average_struct.h.9.41820d0d7dc25dca8a9005c6d1a8bb5f
                           .group:0000000000000000 wm4.telemetry.h.21.a87436b8ee86f5e60170454e063be1e3
                           .group:0000000000000000 wm4.parser.h.9.2d68c8669e0bffa77926bbb9bf5a2aba

UNDEFINED SYMBOLS
ms5611_reset
ms5611_trigger_measure
rte_wx_ms5611_qf
wx_get_temperature_measurement
wx_get_pressure_measurement
wx_get_humidity_measurement
bme280_read_raw_data
bme280_data_buffer
rte_wx_bme280_qf
__aeabi_f2d
__aeabi_dmul
__aeabi_d2iz
analog_anemometer_get_ms_from_pulse
umb_get_winddirection
umb_get_windspeed
umb_get_windgusts
rtu_get_wind_speed
rtu_get_wind_direction
rtu_get_wind_gusts
cosf
sinf
atan2f
analog_anemometer_get_qf
rte_wx_windspeed_it
rte_wx_windspeed
rte_wx_windspeed_pulses
rte_wx_average_winddirection
rte_wx_average_windspeed
rte_wx_max_windspeed
rte_wx_winddirection_last
rte_wx_winddirection_it
rte_wx_winddirection
rte_wx_wind_qf
LL_GPIO_Init
delay_fixed
master_time
